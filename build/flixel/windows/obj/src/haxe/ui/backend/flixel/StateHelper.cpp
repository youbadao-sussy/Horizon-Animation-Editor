// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedContainer
#include <flixel/group/FlxTypedContainer.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_flixel_StateHelper
#include <haxe/ui/backend/flixel/StateHelper.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_6b023349a28ddb16_12_get_currentState,"haxe.ui.backend.flixel.StateHelper","get_currentState",0x0623c8d6,"haxe.ui.backend.flixel.StateHelper.get_currentState","haxe/ui/backend/flixel/StateHelper.hx",12,0xfba12905)
HX_LOCAL_STACK_FRAME(_hx_pos_6b023349a28ddb16_29_hasMember,"haxe.ui.backend.flixel.StateHelper","hasMember",0x5a7b7f7f,"haxe.ui.backend.flixel.StateHelper.hasMember","haxe/ui/backend/flixel/StateHelper.hx",29,0xfba12905)
HX_LOCAL_STACK_FRAME(_hx_pos_6b023349a28ddb16_62_groupHasMember,"haxe.ui.backend.flixel.StateHelper","groupHasMember",0x548d3c0a,"haxe.ui.backend.flixel.StateHelper.groupHasMember","haxe/ui/backend/flixel/StateHelper.hx",62,0xfba12905)
HX_LOCAL_STACK_FRAME(_hx_pos_6b023349a28ddb16_90_findCameras,"haxe.ui.backend.flixel.StateHelper","findCameras",0x98a855e0,"haxe.ui.backend.flixel.StateHelper.findCameras","haxe/ui/backend/flixel/StateHelper.hx",90,0xfba12905)
namespace haxe{
namespace ui{
namespace backend{
namespace flixel{

void StateHelper_obj::__construct() { }

Dynamic StateHelper_obj::__CreateEmpty() { return new StateHelper_obj; }

void *StateHelper_obj::_hx_vtable = 0;

Dynamic StateHelper_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< StateHelper_obj > _hx_result = new StateHelper_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool StateHelper_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4b3d9789;
}

 ::flixel::FlxState StateHelper_obj::currentState;

 ::flixel::FlxState StateHelper_obj::get_currentState(){
            	HX_STACKFRAME(&_hx_pos_6b023349a28ddb16_12_get_currentState)
HXLINE(  13)		 ::flixel::FlxState s = ::flixel::FlxG_obj::game->_state;
HXLINE(  14)		bool _hx_tmp;
HXDLIN(  14)		if (::hx::IsNotNull( s )) {
HXLINE(  14)			_hx_tmp = ::hx::IsNotNull( s->subState );
            		}
            		else {
HXLINE(  14)			_hx_tmp = false;
            		}
HXDLIN(  14)		if (_hx_tmp) {
HXLINE(  15)			 ::flixel::FlxSubState r = s->subState;
HXLINE(  16)			while(::hx::IsNotNull( r )){
HXLINE(  17)				if (::hx::IsNull( r->subState )) {
HXLINE(  18)					goto _hx_goto_0;
            				}
HXLINE(  20)				r = r->subState;
            			}
            			_hx_goto_0:;
HXLINE(  22)			s = r;
            		}
HXLINE(  24)		return s;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(StateHelper_obj,get_currentState,return )

bool StateHelper_obj::hasMember( ::flixel::FlxBasic member, ::flixel::group::FlxTypedGroup group){
            	HX_STACKFRAME(&_hx_pos_6b023349a28ddb16_29_hasMember)
HXDLIN(  29)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StateHelper_obj,hasMember,return )

bool StateHelper_obj::groupHasMember( ::flixel::FlxBasic member, ::flixel::group::FlxTypedSpriteGroup group){
            	HX_STACKFRAME(&_hx_pos_6b023349a28ddb16_62_groupHasMember)
HXLINE(  63)		bool _hx_tmp;
HXDLIN(  63)		if (::hx::IsNotNull( group )) {
HXLINE(  63)			_hx_tmp = !(group->exists);
            		}
            		else {
HXLINE(  63)			_hx_tmp = true;
            		}
HXDLIN(  63)		if (_hx_tmp) {
HXLINE(  64)			return false;
            		}
HXLINE(  67)		if (::hx::IsInstanceEq( member,group )) {
HXLINE(  68)			return true;
            		}
HXLINE(  71)		{
HXLINE(  71)			int _g = 0;
HXDLIN(  71)			::Array< ::Dynamic> _g1 = group->group->members;
HXDLIN(  71)			while((_g < _g1->length)){
HXLINE(  71)				 ::flixel::FlxSprite m = _g1->__get(_g).StaticCast<  ::flixel::FlxSprite >();
HXDLIN(  71)				_g = (_g + 1);
HXLINE(  72)				if (::hx::IsInstanceEq( m,member )) {
HXLINE(  73)					return true;
            				}
HXLINE(  76)				if (::Std_obj::isOfType(m,::hx::ClassOf< ::flixel::group::FlxTypedGroup >())) {
HXLINE(  77)					if ((::haxe::ui::backend::flixel::StateHelper_obj::hasMember(member,( ( ::flixel::group::FlxTypedGroup)(m) )) == true)) {
HXLINE(  78)						return true;
            					}
            				}
            				else {
HXLINE(  80)					if (::Std_obj::isOfType(m,::hx::ClassOf< ::flixel::group::FlxTypedSpriteGroup >())) {
HXLINE(  81)						if ((::haxe::ui::backend::flixel::StateHelper_obj::groupHasMember(member,( ( ::flixel::group::FlxTypedSpriteGroup)(m) )) == true)) {
HXLINE(  82)							return true;
            						}
            					}
            				}
            			}
            		}
HXLINE(  87)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StateHelper_obj,groupHasMember,return )

::Array< ::Dynamic> StateHelper_obj::findCameras( ::flixel::FlxBasic member, ::flixel::group::FlxTypedGroup group){
            	HX_STACKFRAME(&_hx_pos_6b023349a28ddb16_90_findCameras)
HXLINE(  91)		if (::hx::IsNull( group )) {
HXLINE(  92)			group = ::haxe::ui::backend::flixel::StateHelper_obj::get_currentState();
            		}
HXLINE(  95)		bool _hx_tmp;
HXDLIN(  95)		if (::hx::IsNotNull( group )) {
HXLINE(  95)			_hx_tmp = !(group->exists);
            		}
            		else {
HXLINE(  95)			_hx_tmp = true;
            		}
HXDLIN(  95)		if (_hx_tmp) {
HXLINE(  96)			return null();
            		}
HXLINE(  99)		{
HXLINE(  99)			int _g = 0;
HXDLIN(  99)			::Array< ::Dynamic> _g1 = group->members;
HXDLIN(  99)			while((_g < _g1->length)){
HXLINE(  99)				 ::flixel::FlxBasic m = _g1->__get(_g).StaticCast<  ::flixel::FlxBasic >();
HXDLIN(  99)				_g = (_g + 1);
HXLINE( 100)				bool _hx_tmp1;
HXDLIN( 100)				bool _hx_tmp2;
HXDLIN( 100)				if (::hx::IsNotNull( m )) {
HXLINE( 100)					_hx_tmp2 = ::hx::IsNotNull( m->get_cameras() );
            				}
            				else {
HXLINE( 100)					_hx_tmp2 = false;
            				}
HXDLIN( 100)				if (_hx_tmp2) {
HXLINE( 100)					_hx_tmp1 = (m->get_cameras()->length > 0);
            				}
            				else {
HXLINE( 100)					_hx_tmp1 = false;
            				}
HXDLIN( 100)				if (_hx_tmp1) {
HXLINE( 101)					bool _hx_tmp3;
HXDLIN( 101)					if (::hx::IsInstanceNotEq( m,member )) {
HXLINE( 101)						if (::Std_obj::isOfType(m,::hx::ClassOf< ::flixel::group::FlxTypedGroup >())) {
HXLINE( 101)							_hx_tmp3 = ::haxe::ui::backend::flixel::StateHelper_obj::hasMember(member,( ( ::flixel::group::FlxTypedGroup)(m) ));
            						}
            						else {
HXLINE( 101)							_hx_tmp3 = false;
            						}
            					}
            					else {
HXLINE( 101)						_hx_tmp3 = true;
            					}
HXDLIN( 101)					if (_hx_tmp3) {
HXLINE( 102)						return m->get_cameras();
            					}
            				}
            			}
            		}
HXLINE( 107)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StateHelper_obj,findCameras,return )


StateHelper_obj::StateHelper_obj()
{
}

bool StateHelper_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"hasMember") ) { outValue = hasMember_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"findCameras") ) { outValue = findCameras_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentState") ) { outValue = ( inCallProp == ::hx::paccAlways ? get_currentState() : currentState ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"groupHasMember") ) { outValue = groupHasMember_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_currentState") ) { outValue = get_currentState_dyn(); return true; }
	}
	return false;
}

bool StateHelper_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"currentState") ) { currentState=ioValue.Cast<  ::flixel::FlxState >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *StateHelper_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo StateHelper_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxState */ ,(void *) &StateHelper_obj::currentState,HX_("currentState",18,5b,17,cb)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void StateHelper_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(StateHelper_obj::currentState,"currentState");
};

#ifdef HXCPP_VISIT_ALLOCS
static void StateHelper_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(StateHelper_obj::currentState,"currentState");
};

#endif

::hx::Class StateHelper_obj::__mClass;

static ::String StateHelper_obj_sStaticFields[] = {
	HX_("currentState",18,5b,17,cb),
	HX_("get_currentState",a1,47,b6,cf),
	HX_("hasMember",54,95,9e,45),
	HX_("groupHasMember",15,e2,21,d3),
	HX_("findCameras",f5,4a,1c,e3),
	::String(null())
};

void StateHelper_obj::__register()
{
	StateHelper_obj _hx_dummy;
	StateHelper_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.backend.flixel.StateHelper",d9,f6,62,41);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &StateHelper_obj::__GetStatic;
	__mClass->mSetStaticField = &StateHelper_obj::__SetStatic;
	__mClass->mMarkFunc = StateHelper_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(StateHelper_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< StateHelper_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = StateHelper_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = StateHelper_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = StateHelper_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ui
} // end namespace backend
} // end namespace flixel
