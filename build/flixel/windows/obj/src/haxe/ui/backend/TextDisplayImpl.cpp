// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextFormat
#include <flixel/text/FlxTextFormat.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextFormatMarkerPair
#include <flixel/text/FlxTextFormatMarkerPair.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_ui_Toolkit
#include <haxe/ui/Toolkit.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_TextBase
#include <haxe/ui/backend/TextBase.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_TextDisplayImpl
#include <haxe/ui/backend/TextDisplayImpl.h>
#endif
#ifndef INCLUDED_haxe_ui_core_TextDisplayData
#include <haxe/ui/core/TextDisplayData.h>
#endif
#ifndef INCLUDED_haxe_ui_data_DataSource
#include <haxe/ui/data/DataSource.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_Style
#include <haxe/ui/styles/Style.h>
#endif
#ifndef INCLUDED_haxe_ui_util__Color_Color_Impl_
#include <haxe/ui/util/_Color/Color_Impl_.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8071faafd25b045f_12_new,"haxe.ui.backend.TextDisplayImpl","new",0x7f5d76bb,"haxe.ui.backend.TextDisplayImpl.new","haxe/ui/backend/TextDisplayImpl.hx",12,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_20_validateData,"haxe.ui.backend.TextDisplayImpl","validateData",0x126d8c25,"haxe.ui.backend.TextDisplayImpl.validateData","haxe/ui/backend/TextDisplayImpl.hx",20,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_35_validateStyle,"haxe.ui.backend.TextDisplayImpl","validateStyle",0xbd02aad6,"haxe.ui.backend.TextDisplayImpl.validateStyle","haxe/ui/backend/TextDisplayImpl.hx",35,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_83_validateDisplay,"haxe.ui.backend.TextDisplayImpl","validateDisplay",0xbbb7a327,"haxe.ui.backend.TextDisplayImpl.validateDisplay","haxe/ui/backend/TextDisplayImpl.hx",83,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_92_measureText,"haxe.ui.backend.TextDisplayImpl","measureText",0x0670f486,"haxe.ui.backend.TextDisplayImpl.measureText","haxe/ui/backend/TextDisplayImpl.hx",92,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_103_normalizeText,"haxe.ui.backend.TextDisplayImpl","normalizeText",0x0e40c0f5,"haxe.ui.backend.TextDisplayImpl.normalizeText","haxe/ui/backend/TextDisplayImpl.hx",103,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_109_get_supportsHtml,"haxe.ui.backend.TextDisplayImpl","get_supportsHtml",0x9e527e5d,"haxe.ui.backend.TextDisplayImpl.get_supportsHtml","haxe/ui/backend/TextDisplayImpl.hx",109,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_112_processTags,"haxe.ui.backend.TextDisplayImpl","processTags",0x1f7de043,"haxe.ui.backend.TextDisplayImpl.processTags","haxe/ui/backend/TextDisplayImpl.hx",112,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_8_boot,"haxe.ui.backend.TextDisplayImpl","boot",0xea836d77,"haxe.ui.backend.TextDisplayImpl.boot","haxe/ui/backend/TextDisplayImpl.hx",8,0xee590bf6)
namespace haxe{
namespace ui{
namespace backend{

void TextDisplayImpl_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_8071faafd25b045f_12_new)
HXLINE(  13)		super::__construct();
HXLINE(  14)		this->tf =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  15)		this->tf->set_pixelPerfectRender(true);
HXLINE(  16)		this->tf->set_autoSize(true);
            	}

Dynamic TextDisplayImpl_obj::__CreateEmpty() { return new TextDisplayImpl_obj; }

void *TextDisplayImpl_obj::_hx_vtable = 0;

Dynamic TextDisplayImpl_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TextDisplayImpl_obj > _hx_result = new TextDisplayImpl_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TextDisplayImpl_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0b41c5d8) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0b41c5d8;
	} else {
		return inClassId==(int)0x0c38975b;
	}
}

void TextDisplayImpl_obj::validateData(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_20_validateData)
HXDLIN(  20)		if (::hx::IsNotNull( this->_text )) {
HXLINE(  21)			if (::hx::IsNull( this->_dataSource )) {
HXLINE(  22)				 ::flixel::text::FlxText _hx_tmp = this->tf;
HXDLIN(  22)				_hx_tmp->set_text(this->normalizeText(this->_text));
            			}
            		}
            		else {
HXLINE(  24)			if (::hx::IsNotNull( this->_htmlText )) {
HXLINE(  25)				::Array< ::Dynamic> rules = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  26)				::String outText = ::haxe::ui::backend::TextDisplayImpl_obj::processTags(this->_htmlText,rules);
HXLINE(  27)				if ((rules->length > 0)) {
HXLINE(  28)					this->tf->applyMarkup(outText,rules);
            				}
            				else {
HXLINE(  30)					 ::flixel::text::FlxText _hx_tmp1 = this->tf;
HXDLIN(  30)					_hx_tmp1->set_text(this->normalizeText(this->_htmlText));
            				}
            			}
            		}
            	}


bool TextDisplayImpl_obj::validateStyle(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_35_validateStyle)
HXLINE(  36)		bool measureTextRequired = false;
HXLINE(  37)		if (::hx::IsNotNull( this->_textStyle )) {
HXLINE(  38)			if (::hx::IsNotNull( this->_textStyle->textAlign )) {
HXLINE(  40)				this->tf->set_alignment(this->_textStyle->textAlign);
HXLINE(  41)				measureTextRequired = true;
            			}
HXLINE(  44)			if (::hx::IsNotNull( this->_textStyle->fontSize )) {
HXLINE(  45)				 ::flixel::text::FlxText _hx_tmp = this->tf;
HXDLIN(  45)				 ::Dynamic _hx_tmp1 = this->_textStyle->fontSize;
HXDLIN(  45)				_hx_tmp->set_size(::Std_obj::_hx_int((( (Float)(_hx_tmp1) ) * ::haxe::ui::Toolkit_obj::get_scale())));
HXLINE(  46)				measureTextRequired = true;
            			}
HXLINE(  49)			if (::hx::IsNotNull( this->_fontInfo )) {
HXLINE(  50)				this->tf->set_font(( (::String)(this->_fontInfo->__Field(HX_("data",2a,56,63,42),::hx::paccDynamic)) ));
HXLINE(  51)				measureTextRequired = true;
            			}
HXLINE(  54)			if (::hx::IsNotNull( this->_textStyle->fontBold )) {
HXLINE(  55)				this->tf->set_bold(( (bool)(this->_textStyle->fontBold) ));
HXLINE(  56)				measureTextRequired = true;
            			}
HXLINE(  58)			if (::hx::IsNotNull( this->_textStyle->fontItalic )) {
HXLINE(  59)				this->tf->set_italic(( (bool)(this->_textStyle->fontItalic) ));
HXLINE(  60)				measureTextRequired = true;
            			}
HXLINE(  63)			if (::hx::IsNotNull( this->_textStyle->color )) {
HXLINE(  64)				this->tf->set_color(( (int)(this->_textStyle->color) ));
            			}
HXLINE(  67)			bool _hx_tmp2 = this->tf->textField->get_wordWrap();
HXDLIN(  67)			if ((_hx_tmp2 != this->_displayData->wordWrap)) {
HXLINE(  68)				this->tf->set_wordWrap(this->_displayData->wordWrap);
HXLINE(  70)				measureTextRequired = true;
            			}
HXLINE(  73)			bool _hx_tmp3 = this->tf->textField->get_multiline();
HXDLIN(  73)			if ((_hx_tmp3 != this->_displayData->multiline)) {
HXLINE(  74)				this->tf->textField->set_multiline(this->_displayData->multiline);
HXLINE(  76)				measureTextRequired = true;
            			}
            		}
HXLINE(  80)		return measureTextRequired;
            	}


void TextDisplayImpl_obj::validateDisplay(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_83_validateDisplay)
HXLINE(  84)		Float _hx_tmp = this->tf->textField->get_width();
HXDLIN(  84)		if ((_hx_tmp != this->_width)) {
HXLINE(  85)			 ::openfl::text::TextField _hx_tmp1 = this->tf->textField;
HXDLIN(  85)			Float _hx_tmp2 = this->_width;
HXDLIN(  85)			_hx_tmp1->set_width((_hx_tmp2 * ::haxe::ui::Toolkit_obj::get_scaleX()));
            		}
HXLINE(  87)		Float _hx_tmp3 = this->tf->textField->get_height();
HXDLIN(  87)		if ((_hx_tmp3 != this->_height)) {
HXLINE(  88)			 ::openfl::text::TextField _hx_tmp4 = this->tf->textField;
HXDLIN(  88)			Float _hx_tmp5 = this->_height;
HXDLIN(  88)			_hx_tmp4->set_height((_hx_tmp5 * ::haxe::ui::Toolkit_obj::get_scaleY()));
            		}
            	}


void TextDisplayImpl_obj::measureText(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_92_measureText)
HXLINE(  93)		Float _hx_tmp = ::Math_obj::fround(this->tf->textField->get_textWidth());
HXDLIN(  93)		Float _hx_tmp1 = (_hx_tmp + (( (Float)(2) ) * ::haxe::ui::Toolkit_obj::get_scaleX()));
HXDLIN(  93)		this->_textWidth = (_hx_tmp1 / ::haxe::ui::Toolkit_obj::get_scaleX());
HXLINE(  94)		Float _hx_tmp2 = ::Math_obj::fround(this->tf->textField->get_textHeight());
HXDLIN(  94)		this->_textHeight = (_hx_tmp2 / ::haxe::ui::Toolkit_obj::get_scaleY());
HXLINE(  95)		if ((this->_textHeight == 0)) {
HXLINE(  96)			::String tmpText = this->tf->text;
HXLINE(  97)			this->tf->set_text(HX_("|",7c,00,00,00));
HXLINE(  98)			this->_textHeight = this->tf->textField->get_textHeight();
HXLINE(  99)			this->tf->set_text(tmpText);
            		}
            	}


::String TextDisplayImpl_obj::normalizeText(::String text){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_103_normalizeText)
HXLINE( 104)		text = ::StringTools_obj::replace(text,HX_("\\n",92,50,00,00),HX_("\n",0a,00,00,00));
HXLINE( 105)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TextDisplayImpl_obj,normalizeText,return )

bool TextDisplayImpl_obj::get_supportsHtml(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_109_get_supportsHtml)
HXDLIN( 109)		return true;
            	}


int TextDisplayImpl_obj::PADDING_X;

::String TextDisplayImpl_obj::processTags(::String s,::Array< ::Dynamic> rules){
            	HX_GC_STACKFRAME(&_hx_pos_8071faafd25b045f_112_processTags)
HXLINE( 113)		bool inTag = false;
HXLINE( 114)		bool endTag = false;
HXLINE( 115)		::String tagDetails = HX_("",00,00,00,00);
HXLINE( 116)		::String out = HX_("",00,00,00,00);
HXLINE( 118)		::Array< ::String > tagStack = ::Array_obj< ::String >::__new(0);
HXLINE( 119)		 ::haxe::ds::StringMap colorMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 121)		{
HXLINE( 121)			int _g = 0;
HXDLIN( 121)			int _g1 = s.length;
HXDLIN( 121)			while((_g < _g1)){
HXLINE( 121)				_g = (_g + 1);
HXDLIN( 121)				int i = (_g - 1);
HXLINE( 122)				::String c = s.charAt(i);
HXLINE( 123)				::String _hx_switch_0 = c;
            				if (  (_hx_switch_0==HX_("/",2f,00,00,00)) ){
HXLINE( 132)					if ((inTag == true)) {
HXLINE( 133)						endTag = true;
            					}
HXLINE( 132)					goto _hx_goto_8;
            				}
            				if (  (_hx_switch_0==HX_("<",3c,00,00,00)) ){
HXLINE( 125)					::String temp = s.substring((i + 1),(i + 6));
HXLINE( 126)					bool _hx_tmp;
HXDLIN( 126)					if ((temp != HX_("font ",71,b7,91,04))) {
HXLINE( 126)						_hx_tmp = (temp == HX_("/font",7e,a1,95,53));
            					}
            					else {
HXLINE( 126)						_hx_tmp = true;
            					}
HXDLIN( 126)					if (_hx_tmp) {
HXLINE( 127)						inTag = true;
HXLINE( 128)						endTag = false;
HXLINE( 129)						tagDetails = HX_("",00,00,00,00);
            					}
HXLINE( 124)					goto _hx_goto_8;
            				}
            				if (  (_hx_switch_0==HX_(">",3e,00,00,00)) ){
HXLINE( 136)					if ((inTag == true)) {
HXLINE( 137)						if ((endTag == false)) {
HXLINE( 138)							int n = tagDetails.indexOf(HX_("color=",7a,c5,86,c6),null());
HXLINE( 139)							if ((n != -1)) {
HXLINE( 140)								::String col = tagDetails.substring((n + HX_("color=",7a,c5,86,c6).length),null());
HXLINE( 141)								col = ::StringTools_obj::replace(col,HX_("'",27,00,00,00),HX_("",00,00,00,00));
HXLINE( 142)								col = ::StringTools_obj::replace(col,HX_("\"",22,00,00,00),HX_("",00,00,00,00));
HXLINE( 143)								tagStack->push(col);
HXLINE( 144)								out = (out + ((HX_("<",3c,00,00,00) + col) + HX_(">",3e,00,00,00)));
HXLINE( 145)								colorMap->set(((HX_("<",3c,00,00,00) + col) + HX_(">",3e,00,00,00)),::haxe::ui::util::_Color::Color_Impl__obj::toInt(::haxe::ui::util::_Color::Color_Impl__obj::fromString(col)));
            							}
            							else {
HXLINE( 147)								tagStack->push(tagDetails);
HXLINE( 148)								out = (out + tagDetails);
            							}
            						}
            						else {
HXLINE( 152)							::String startTagDetails = ( (::String)(tagStack->pop()) );
HXLINE( 153)							out = (out + ((HX_("<",3c,00,00,00) + startTagDetails) + HX_(">",3e,00,00,00)));
            						}
HXLINE( 155)						inTag = false;
            					}
HXLINE( 136)					goto _hx_goto_8;
            				}
            				/* default */{
HXLINE( 158)					if ((inTag == true)) {
HXLINE( 159)						tagDetails = (tagDetails + c.toLowerCase());
            					}
            					else {
HXLINE( 161)						out = (out + c);
            					}
            				}
            				_hx_goto_8:;
            			}
            		}
HXLINE( 166)		{
HXLINE( 166)			 ::Dynamic k = colorMap->keys();
HXDLIN( 166)			while(( (bool)(k->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 166)				::String k1 = ( (::String)(k->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 167)				rules->push( ::flixel::text::FlxTextFormatMarkerPair_obj::__alloc( HX_CTX , ::flixel::text::FlxTextFormat_obj::__alloc( HX_CTX ,colorMap->get(k1),null(),null(),null(),null()),k1));
            			}
            		}
HXLINE( 170)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(TextDisplayImpl_obj,processTags,return )


::hx::ObjectPtr< TextDisplayImpl_obj > TextDisplayImpl_obj::__new() {
	::hx::ObjectPtr< TextDisplayImpl_obj > __this = new TextDisplayImpl_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< TextDisplayImpl_obj > TextDisplayImpl_obj::__alloc(::hx::Ctx *_hx_ctx) {
	TextDisplayImpl_obj *__this = (TextDisplayImpl_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TextDisplayImpl_obj), true, "haxe.ui.backend.TextDisplayImpl"));
	*(void **)__this = TextDisplayImpl_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

TextDisplayImpl_obj::TextDisplayImpl_obj()
{
}

void TextDisplayImpl_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TextDisplayImpl);
	HX_MARK_MEMBER_NAME(tf,"tf");
	 ::haxe::ui::backend::TextBase_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TextDisplayImpl_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(tf,"tf");
	 ::haxe::ui::backend::TextBase_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TextDisplayImpl_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"tf") ) { return ::hx::Val( tf ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"measureText") ) { return ::hx::Val( measureText_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"validateData") ) { return ::hx::Val( validateData_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"validateStyle") ) { return ::hx::Val( validateStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"normalizeText") ) { return ::hx::Val( normalizeText_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"validateDisplay") ) { return ::hx::Val( validateDisplay_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_supportsHtml") ) { return ::hx::Val( get_supportsHtml_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool TextDisplayImpl_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"processTags") ) { outValue = processTags_dyn(); return true; }
	}
	return false;
}

::hx::Val TextDisplayImpl_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"tf") ) { tf=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TextDisplayImpl_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("tf",72,65,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TextDisplayImpl_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(TextDisplayImpl_obj,tf),HX_("tf",72,65,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo TextDisplayImpl_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &TextDisplayImpl_obj::PADDING_X,HX_("PADDING_X",0a,0f,3d,e9)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String TextDisplayImpl_obj_sMemberFields[] = {
	HX_("tf",72,65,00,00),
	HX_("validateData",e0,55,63,96),
	HX_("validateStyle",bb,64,1d,b0),
	HX_("validateDisplay",4c,60,60,b6),
	HX_("measureText",2b,fb,80,50),
	HX_("normalizeText",da,7a,5b,01),
	HX_("get_supportsHtml",98,41,4f,f7),
	::String(null()) };

static void TextDisplayImpl_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TextDisplayImpl_obj::PADDING_X,"PADDING_X");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TextDisplayImpl_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TextDisplayImpl_obj::PADDING_X,"PADDING_X");
};

#endif

::hx::Class TextDisplayImpl_obj::__mClass;

static ::String TextDisplayImpl_obj_sStaticFields[] = {
	HX_("PADDING_X",0a,0f,3d,e9),
	HX_("processTags",e8,e6,8d,69),
	::String(null())
};

void TextDisplayImpl_obj::__register()
{
	TextDisplayImpl_obj _hx_dummy;
	TextDisplayImpl_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.backend.TextDisplayImpl",49,fd,9e,50);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TextDisplayImpl_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = TextDisplayImpl_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TextDisplayImpl_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TextDisplayImpl_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TextDisplayImpl_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TextDisplayImpl_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TextDisplayImpl_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TextDisplayImpl_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void TextDisplayImpl_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_8_boot)
HXDLIN(   8)		PADDING_X = 2;
            	}
}

} // end namespace haxe
} // end namespace ui
} // end namespace backend
