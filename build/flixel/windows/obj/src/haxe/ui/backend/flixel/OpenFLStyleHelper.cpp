// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ui_Toolkit
#include <haxe/ui/Toolkit.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_flixel_OpenFLStyleHelper
#include <haxe/ui/backend/flixel/OpenFLStyleHelper.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_Style
#include <haxe/ui/styles/Style.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ea9b7a52d4882d09_12_new,"haxe.ui.backend.flixel.OpenFLStyleHelper","new",0x2411e93b,"haxe.ui.backend.flixel.OpenFLStyleHelper.new","haxe/ui/backend/flixel/OpenFLStyleHelper.hx",12,0x0232c615)
HX_LOCAL_STACK_FRAME(_hx_pos_ea9b7a52d4882d09_15_paintStyleSection,"haxe.ui.backend.flixel.OpenFLStyleHelper","paintStyleSection",0x7240bb8d,"haxe.ui.backend.flixel.OpenFLStyleHelper.paintStyleSection","haxe/ui/backend/flixel/OpenFLStyleHelper.hx",15,0x0232c615)
static const int _hx_array_data_90882fc9_2[] = {
	(int)0,(int)255,
};
namespace haxe{
namespace ui{
namespace backend{
namespace flixel{

void OpenFLStyleHelper_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_ea9b7a52d4882d09_12_new)
            	}

Dynamic OpenFLStyleHelper_obj::__CreateEmpty() { return new OpenFLStyleHelper_obj; }

void *OpenFLStyleHelper_obj::_hx_vtable = 0;

Dynamic OpenFLStyleHelper_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< OpenFLStyleHelper_obj > _hx_result = new OpenFLStyleHelper_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool OpenFLStyleHelper_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7adc7479;
}

void OpenFLStyleHelper_obj::paintStyleSection( ::openfl::display::Graphics graphics, ::haxe::ui::styles::Style style,Float width,Float height,::hx::Null< Float >  __o_left,::hx::Null< Float >  __o_top,::hx::Null< bool >  __o_clear){
            		Float left = __o_left.Default(0);
            		Float top = __o_top.Default(0);
            		bool clear = __o_clear.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_ea9b7a52d4882d09_15_paintStyleSection)
HXLINE(  16)		if ((clear == true)) {
HXLINE(  17)			graphics->clear();
            		}
HXLINE(  20)		bool _hx_tmp;
HXDLIN(  20)		if (!((width <= 0))) {
HXLINE(  20)			_hx_tmp = (height <= 0);
            		}
            		else {
HXLINE(  20)			_hx_tmp = true;
            		}
HXDLIN(  20)		if (_hx_tmp) {
HXLINE(  21)			return;
            		}
HXLINE(  31)		left = ( (Float)(::Std_obj::_hx_int(left)) );
HXLINE(  32)		top = ( (Float)(::Std_obj::_hx_int(top)) );
HXLINE(  33)		width = ( (Float)(::Std_obj::_hx_int(width)) );
HXLINE(  34)		height = ( (Float)(::Std_obj::_hx_int(height)) );
HXLINE(  36)		bool hasFullStyledBorder = false;
HXLINE(  37)		::String borderStyle = style->borderStyle;
HXLINE(  38)		if (::hx::IsNull( borderStyle )) {
HXLINE(  39)			borderStyle = HX_("solid",2b,b4,c5,80);
            		}
HXLINE(  42)		 ::openfl::geom::Rectangle rc =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,top,left,width,height);
HXLINE(  43)		Float borderRadius = ( (Float)(0) );
HXLINE(  44)		if (::hx::IsNotNull( style->borderRadius )) {
HXLINE(  45)			 ::Dynamic style1 = style->borderRadius;
HXDLIN(  45)			borderRadius = (( (Float)(style1) ) * ::haxe::ui::Toolkit_obj::get_scale());
            		}
HXLINE(  48)		bool _hx_tmp1;
HXDLIN(  48)		bool _hx_tmp2;
HXDLIN(  48)		bool _hx_tmp3;
HXDLIN(  48)		bool _hx_tmp4;
HXDLIN(  48)		bool _hx_tmp5;
HXDLIN(  48)		bool _hx_tmp6;
HXDLIN(  48)		bool _hx_tmp7;
HXDLIN(  48)		bool _hx_tmp8;
HXDLIN(  48)		if (::hx::IsNotNull( style->borderLeftSize )) {
HXLINE(  48)			_hx_tmp8 = ::hx::IsNotEq( style->borderLeftSize,0 );
            		}
            		else {
HXLINE(  48)			_hx_tmp8 = false;
            		}
HXDLIN(  48)		if (_hx_tmp8) {
HXLINE(  48)			_hx_tmp7 = ::hx::IsEq( style->borderLeftSize,style->borderRightSize );
            		}
            		else {
HXLINE(  48)			_hx_tmp7 = false;
            		}
HXDLIN(  48)		if (_hx_tmp7) {
HXLINE(  48)			_hx_tmp6 = ::hx::IsEq( style->borderLeftSize,style->borderBottomSize );
            		}
            		else {
HXLINE(  48)			_hx_tmp6 = false;
            		}
HXDLIN(  48)		if (_hx_tmp6) {
HXLINE(  48)			_hx_tmp5 = ::hx::IsEq( style->borderLeftSize,style->borderTopSize );
            		}
            		else {
HXLINE(  48)			_hx_tmp5 = false;
            		}
HXDLIN(  48)		if (_hx_tmp5) {
HXLINE(  48)			_hx_tmp4 = ::hx::IsNotNull( style->borderLeftColor );
            		}
            		else {
HXLINE(  48)			_hx_tmp4 = false;
            		}
HXDLIN(  48)		if (_hx_tmp4) {
HXLINE(  48)			_hx_tmp3 = ::hx::IsEq( style->borderLeftColor,style->borderRightColor );
            		}
            		else {
HXLINE(  48)			_hx_tmp3 = false;
            		}
HXDLIN(  48)		if (_hx_tmp3) {
HXLINE(  48)			_hx_tmp2 = ::hx::IsEq( style->borderLeftColor,style->borderBottomColor );
            		}
            		else {
HXLINE(  48)			_hx_tmp2 = false;
            		}
HXDLIN(  48)		if (_hx_tmp2) {
HXLINE(  48)			_hx_tmp1 = ::hx::IsEq( style->borderLeftColor,style->borderTopColor );
            		}
            		else {
HXLINE(  48)			_hx_tmp1 = false;
            		}
HXDLIN(  48)		if (_hx_tmp1) {
HXLINE(  58)			 ::Dynamic style2 = style->borderLeftSize;
HXDLIN(  58)			Float _hx_tmp9 = (( (Float)(style2) ) * ::haxe::ui::Toolkit_obj::get_scale());
HXDLIN(  58)			graphics->lineStyle(_hx_tmp9,style->borderLeftColor,null(),null(),null(),null(),null(),null());
HXLINE(  59)			Float _hx_tmp10 = rc->get_left();
HXDLIN(  59)			 ::Dynamic style3 = style->borderLeftSize;
HXDLIN(  59)			rc->set_left((_hx_tmp10 + ((( (Float)(style3) ) * ::haxe::ui::Toolkit_obj::get_scale()) / ( (Float)(2) ))));
HXLINE(  60)			Float _hx_tmp11 = rc->get_top();
HXDLIN(  60)			 ::Dynamic style4 = style->borderLeftSize;
HXDLIN(  60)			rc->set_top((_hx_tmp11 + ((( (Float)(style4) ) * ::haxe::ui::Toolkit_obj::get_scale()) / ( (Float)(2) ))));
HXLINE(  61)			Float _hx_tmp12 = rc->get_bottom();
HXDLIN(  61)			 ::Dynamic style5 = style->borderLeftSize;
HXDLIN(  61)			rc->set_bottom((_hx_tmp12 - ((( (Float)(style5) ) * ::haxe::ui::Toolkit_obj::get_scale()) / ( (Float)(2) ))));
HXLINE(  62)			Float _hx_tmp13 = rc->get_right();
HXDLIN(  62)			 ::Dynamic style6 = style->borderLeftSize;
HXDLIN(  62)			rc->set_right((_hx_tmp13 - ((( (Float)(style6) ) * ::haxe::ui::Toolkit_obj::get_scale()) / ( (Float)(2) ))));
            		}
            		else {
HXLINE(  65)			bool _hx_tmp14;
HXDLIN(  65)			bool _hx_tmp15;
HXDLIN(  65)			bool _hx_tmp16;
HXDLIN(  65)			bool _hx_tmp17;
HXDLIN(  65)			if (::hx::IsNotNull( style->borderTopSize )) {
HXLINE(  65)				_hx_tmp17 = ::hx::IsGreater( style->borderTopSize,0 );
            			}
            			else {
HXLINE(  65)				_hx_tmp17 = false;
            			}
HXDLIN(  65)			if (!(_hx_tmp17)) {
HXLINE(  66)				if (::hx::IsNotNull( style->borderBottomSize )) {
HXLINE(  65)					_hx_tmp16 = ::hx::IsGreater( style->borderBottomSize,0 );
            				}
            				else {
HXLINE(  65)					_hx_tmp16 = false;
            				}
            			}
            			else {
HXLINE(  65)				_hx_tmp16 = true;
            			}
HXDLIN(  65)			if (!(_hx_tmp16)) {
HXLINE(  67)				if (::hx::IsNotNull( style->borderLeftSize )) {
HXLINE(  65)					_hx_tmp15 = ::hx::IsGreater( style->borderLeftSize,0 );
            				}
            				else {
HXLINE(  65)					_hx_tmp15 = false;
            				}
            			}
            			else {
HXLINE(  65)				_hx_tmp15 = true;
            			}
HXDLIN(  65)			if (!(_hx_tmp15)) {
HXLINE(  68)				if (::hx::IsNotNull( style->borderRightSize )) {
HXLINE(  65)					_hx_tmp14 = ::hx::IsGreater( style->borderRightSize,0 );
            				}
            				else {
HXLINE(  65)					_hx_tmp14 = false;
            				}
            			}
            			else {
HXLINE(  65)				_hx_tmp14 = true;
            			}
HXDLIN(  65)			if (_hx_tmp14) {
HXLINE(  70)				 ::openfl::geom::Rectangle org = rc->clone();
HXLINE(  72)				bool _hx_tmp18;
HXDLIN(  72)				if (::hx::IsNotNull( style->borderTopSize )) {
HXLINE(  72)					_hx_tmp18 = ::hx::IsGreater( style->borderTopSize,0 );
            				}
            				else {
HXLINE(  72)					_hx_tmp18 = false;
            				}
HXDLIN(  72)				if (_hx_tmp18) {
HXLINE(  73)					graphics->beginFill(style->borderTopColor,null());
HXLINE(  74)					Float org1 = org->width;
HXDLIN(  74)					 ::Dynamic style7 = style->borderTopSize;
HXDLIN(  74)					graphics->drawRect(( (Float)(0) ),( (Float)(0) ),org1,(( (Float)(style7) ) * ::haxe::ui::Toolkit_obj::get_scale()));
HXLINE(  75)					graphics->endFill();
HXLINE(  77)					Float _hx_tmp19 = rc->get_top();
HXDLIN(  77)					 ::Dynamic style8 = style->borderTopSize;
HXDLIN(  77)					rc->set_top((_hx_tmp19 + (( (Float)(style8) ) * ::haxe::ui::Toolkit_obj::get_scale())));
            				}
HXLINE(  80)				bool _hx_tmp20;
HXDLIN(  80)				if (::hx::IsNotNull( style->borderBottomSize )) {
HXLINE(  80)					_hx_tmp20 = ::hx::IsGreater( style->borderBottomSize,0 );
            				}
            				else {
HXLINE(  80)					_hx_tmp20 = false;
            				}
HXDLIN(  80)				if (_hx_tmp20) {
HXLINE(  81)					graphics->beginFill(style->borderBottomColor,null());
HXLINE(  82)					Float org2 = org->height;
HXDLIN(  82)					 ::Dynamic style9 = style->borderBottomSize;
HXDLIN(  82)					Float _hx_tmp21 = (org2 - (( (Float)(style9) ) * ::haxe::ui::Toolkit_obj::get_scale()));
HXDLIN(  82)					Float org3 = org->width;
HXDLIN(  82)					 ::Dynamic style10 = style->borderBottomSize;
HXDLIN(  82)					graphics->drawRect(( (Float)(0) ),_hx_tmp21,org3,(( (Float)(style10) ) * ::haxe::ui::Toolkit_obj::get_scale()));
HXLINE(  83)					graphics->endFill();
HXLINE(  85)					Float _hx_tmp22 = rc->get_bottom();
HXDLIN(  85)					 ::Dynamic style11 = style->borderBottomSize;
HXDLIN(  85)					rc->set_bottom((_hx_tmp22 - (( (Float)(style11) ) * ::haxe::ui::Toolkit_obj::get_scale())));
            				}
HXLINE(  88)				bool _hx_tmp23;
HXDLIN(  88)				if (::hx::IsNotNull( style->borderLeftSize )) {
HXLINE(  88)					_hx_tmp23 = ::hx::IsGreater( style->borderLeftSize,0 );
            				}
            				else {
HXLINE(  88)					_hx_tmp23 = false;
            				}
HXDLIN(  88)				if (_hx_tmp23) {
HXLINE(  89)					graphics->beginFill(style->borderLeftColor,null());
HXLINE(  90)					Float _hx_tmp24 = rc->get_top();
HXDLIN(  90)					 ::Dynamic style12 = style->borderLeftSize;
HXDLIN(  90)					Float _hx_tmp25 = (( (Float)(style12) ) * ::haxe::ui::Toolkit_obj::get_scale());
HXDLIN(  90)					Float org4 = org->height;
HXDLIN(  90)					graphics->drawRect(( (Float)(0) ),_hx_tmp24,_hx_tmp25,(org4 - rc->get_top()));
HXLINE(  91)					graphics->endFill();
HXLINE(  93)					Float _hx_tmp26 = rc->get_left();
HXDLIN(  93)					 ::Dynamic style13 = style->borderLeftSize;
HXDLIN(  93)					rc->set_left((_hx_tmp26 + (( (Float)(style13) ) * ::haxe::ui::Toolkit_obj::get_scale())));
            				}
HXLINE(  96)				bool _hx_tmp27;
HXDLIN(  96)				if (::hx::IsNotNull( style->borderRightSize )) {
HXLINE(  96)					_hx_tmp27 = ::hx::IsGreater( style->borderRightSize,0 );
            				}
            				else {
HXLINE(  96)					_hx_tmp27 = false;
            				}
HXDLIN(  96)				if (_hx_tmp27) {
HXLINE(  97)					graphics->beginFill(style->borderRightColor,null());
HXLINE(  98)					Float org5 = org->width;
HXDLIN(  98)					 ::Dynamic style14 = style->borderRightSize;
HXDLIN(  98)					Float _hx_tmp28 = (org5 - (( (Float)(style14) ) * ::haxe::ui::Toolkit_obj::get_scale()));
HXDLIN(  98)					Float _hx_tmp29 = rc->get_top();
HXDLIN(  98)					 ::Dynamic style15 = style->borderRightSize;
HXDLIN(  98)					Float _hx_tmp30 = (( (Float)(style15) ) * ::haxe::ui::Toolkit_obj::get_scale());
HXDLIN(  98)					Float org6 = org->height;
HXDLIN(  98)					graphics->drawRect(_hx_tmp28,_hx_tmp29,_hx_tmp30,(org6 - rc->get_top()));
HXLINE(  99)					graphics->endFill();
HXLINE( 101)					Float _hx_tmp31 = rc->get_right();
HXDLIN( 101)					 ::Dynamic style16 = style->borderRightSize;
HXDLIN( 101)					rc->set_right((_hx_tmp31 - (( (Float)(style16) ) * ::haxe::ui::Toolkit_obj::get_scale())));
            				}
            			}
            		}
HXLINE( 106)		 ::Dynamic backgroundColor = style->backgroundColor;
HXLINE( 107)		 ::Dynamic backgroundColorEnd = style->backgroundColorEnd;
HXLINE( 108)		 ::Dynamic backgroundOpacity = style->backgroundOpacity;
HXLINE( 115)		if (::hx::IsNull( backgroundOpacity )) {
HXLINE( 116)			backgroundOpacity = 1;
            		}
HXLINE( 119)		if (::hx::IsNotNull( backgroundColor )) {
HXLINE( 120)			if (::hx::IsNotNull( backgroundColorEnd )) {
HXLINE( 121)				int w = ::Std_obj::_hx_int(rc->width);
HXLINE( 122)				int h = ::Std_obj::_hx_int(rc->height);
HXLINE( 123)				::Array< int > colors = ::Array_obj< int >::__new(2)->init(0,backgroundColor)->init(1,backgroundColorEnd);
HXLINE( 124)				::Array< Float > alphas = ::Array_obj< Float >::__new(2)->init(0,backgroundOpacity)->init(1,backgroundOpacity);
HXLINE( 125)				::Array< int > ratios = ::Array_obj< int >::fromData( _hx_array_data_90882fc9_2,2);
HXLINE( 126)				 ::openfl::geom::Matrix matrix =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 128)				::String gradientType = HX_("vertical",76,bc,15,6a);
HXLINE( 129)				if (::hx::IsNotNull( style->backgroundGradientStyle )) {
HXLINE( 130)					gradientType = style->backgroundGradientStyle;
            				}
HXLINE( 133)				if ((gradientType == HX_("vertical",76,bc,15,6a))) {
HXLINE( 134)					matrix->createGradientBox(( (Float)((w - 2)) ),( (Float)((h - 2)) ),(::Math_obj::PI / ( (Float)(2) )),0,0);
            				}
            				else {
HXLINE( 135)					if ((gradientType == HX_("horizontal",e4,fc,c3,15))) {
HXLINE( 136)						matrix->createGradientBox(( (Float)((w - 2)) ),( (Float)((h - 2)) ),0,0,0);
            					}
            				}
HXLINE( 139)				graphics->beginGradientFill(0,colors,alphas,ratios,matrix,0,0,0);
            			}
            			else {
HXLINE( 148)				graphics->beginFill(backgroundColor,backgroundOpacity);
            			}
            		}
HXLINE( 152)		if ((borderRadius == 0)) {
HXLINE( 153)			bool _hx_tmp32;
HXDLIN( 153)			bool _hx_tmp33;
HXDLIN( 153)			bool _hx_tmp34;
HXDLIN( 153)			if (::hx::IsNull( style->borderRadiusTopLeft )) {
HXLINE( 153)				_hx_tmp34 = ::hx::IsNotNull( style->borderRadiusTopRight );
            			}
            			else {
HXLINE( 153)				_hx_tmp34 = true;
            			}
HXDLIN( 153)			if (!(_hx_tmp34)) {
HXLINE( 153)				_hx_tmp33 = ::hx::IsNotNull( style->borderRadiusBottomLeft );
            			}
            			else {
HXLINE( 153)				_hx_tmp33 = true;
            			}
HXDLIN( 153)			if (!(_hx_tmp33)) {
HXLINE( 153)				_hx_tmp32 = ::hx::IsNotNull( style->borderRadiusBottomRight );
            			}
            			else {
HXLINE( 153)				_hx_tmp32 = true;
            			}
HXDLIN( 153)			if (_hx_tmp32) {
HXLINE( 154)				Float _hx_tmp35 = rc->get_left();
HXDLIN( 154)				Float _hx_tmp36 = rc->get_top();
HXDLIN( 154)				graphics->drawRoundRectComplex(_hx_tmp35,_hx_tmp36,rc->width,rc->height,( (Float)(style->borderRadiusTopLeft) ),( (Float)(style->borderRadiusTopRight) ),( (Float)(style->borderRadiusBottomLeft) ),( (Float)(style->borderRadiusBottomRight) ));
            			}
            			else {
HXLINE( 155)				if (hasFullStyledBorder) {
HXLINE( 156)					Float _hx_tmp37 = rc->get_left();
HXDLIN( 156)					Float _hx_tmp38 = rc->get_top();
HXDLIN( 156)					graphics->drawRect(_hx_tmp37,_hx_tmp38,rc->width,rc->height);
            				}
            				else {
HXLINE( 158)					Float _hx_tmp39 = rc->get_left();
HXDLIN( 158)					Float _hx_tmp40 = rc->get_top();
HXDLIN( 158)					graphics->drawRect(_hx_tmp39,_hx_tmp40,rc->width,rc->height);
            				}
            			}
            		}
            		else {
HXLINE( 161)			bool _hx_tmp41;
HXDLIN( 161)			if ((rc->width == rc->height)) {
HXLINE( 161)				_hx_tmp41 = (borderRadius >= (rc->width / ( (Float)(2) )));
            			}
            			else {
HXLINE( 161)				_hx_tmp41 = false;
            			}
HXDLIN( 161)			if (_hx_tmp41) {
HXLINE( 162)				borderRadius = (rc->width - ( (Float)(1) ));
            			}
HXLINE( 164)			Float _hx_tmp42 = rc->get_left();
HXDLIN( 164)			Float _hx_tmp43 = rc->get_top();
HXDLIN( 164)			graphics->drawRoundRect(_hx_tmp42,_hx_tmp43,rc->width,rc->height,(borderRadius + 1),(borderRadius + 1));
            		}
HXLINE( 167)		graphics->endFill();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(OpenFLStyleHelper_obj,paintStyleSection,(void))


OpenFLStyleHelper_obj::OpenFLStyleHelper_obj()
{
}

bool OpenFLStyleHelper_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"paintStyleSection") ) { outValue = paintStyleSection_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *OpenFLStyleHelper_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *OpenFLStyleHelper_obj_sStaticStorageInfo = 0;
#endif

::hx::Class OpenFLStyleHelper_obj::__mClass;

static ::String OpenFLStyleHelper_obj_sStaticFields[] = {
	HX_("paintStyleSection",72,f9,c6,73),
	::String(null())
};

void OpenFLStyleHelper_obj::__register()
{
	OpenFLStyleHelper_obj _hx_dummy;
	OpenFLStyleHelper_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.backend.flixel.OpenFLStyleHelper",c9,2f,88,90);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &OpenFLStyleHelper_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(OpenFLStyleHelper_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< OpenFLStyleHelper_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OpenFLStyleHelper_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OpenFLStyleHelper_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ui
} // end namespace backend
} // end namespace flixel
