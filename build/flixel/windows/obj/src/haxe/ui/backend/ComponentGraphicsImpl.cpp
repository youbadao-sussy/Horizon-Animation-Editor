// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_ComponentBase
#include <haxe/ui/backend/ComponentBase.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_ComponentGraphicsBase
#include <haxe/ui/backend/ComponentGraphicsBase.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_ComponentGraphicsImpl
#include <haxe/ui/backend/ComponentGraphicsImpl.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_ComponentImpl
#include <haxe/ui/backend/ComponentImpl.h>
#endif
#ifndef INCLUDED_haxe_ui_core_Component
#include <haxe/ui/core/Component.h>
#endif
#ifndef INCLUDED_haxe_ui_core_IClonable
#include <haxe/ui/core/IClonable.h>
#endif
#ifndef INCLUDED_haxe_ui_core_IComponentContainer
#include <haxe/ui/core/IComponentContainer.h>
#endif
#ifndef INCLUDED_haxe_ui_core_IEventDispatcher
#include <haxe/ui/core/IEventDispatcher.h>
#endif
#ifndef INCLUDED_haxe_ui_validation_IValidating
#include <haxe/ui/validation/IValidating.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl_utils__ByteArray_ByteArray_Impl_
#include <openfl/utils/_ByteArray/ByteArray_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_401f586f6ef1a56f_10_new,"haxe.ui.backend.ComponentGraphicsImpl","new",0x0f4d464e,"haxe.ui.backend.ComponentGraphicsImpl.new","haxe/ui/backend/ComponentGraphicsImpl.hx",10,0xde336e83)
HX_LOCAL_STACK_FRAME(_hx_pos_401f586f6ef1a56f_15_setPixels,"haxe.ui.backend.ComponentGraphicsImpl","setPixels",0xf44500dd,"haxe.ui.backend.ComponentGraphicsImpl.setPixels","haxe/ui/backend/ComponentGraphicsImpl.hx",15,0xde336e83)
HX_LOCAL_STACK_FRAME(_hx_pos_401f586f6ef1a56f_58_resize,"haxe.ui.backend.ComponentGraphicsImpl","resize",0xce69ccc6,"haxe.ui.backend.ComponentGraphicsImpl.resize","haxe/ui/backend/ComponentGraphicsImpl.hx",58,0xde336e83)
namespace haxe{
namespace ui{
namespace backend{

void ComponentGraphicsImpl_obj::__construct( ::haxe::ui::core::Component component){
            	HX_STACKFRAME(&_hx_pos_401f586f6ef1a56f_10_new)
HXLINE(  12)		this->bitmapData = null();
HXLINE(  11)		this->_hasSize = false;
HXLINE(  10)		super::__construct(component);
            	}

Dynamic ComponentGraphicsImpl_obj::__CreateEmpty() { return new ComponentGraphicsImpl_obj; }

void *ComponentGraphicsImpl_obj::_hx_vtable = 0;

Dynamic ComponentGraphicsImpl_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ComponentGraphicsImpl_obj > _hx_result = new ComponentGraphicsImpl_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool ComponentGraphicsImpl_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x292a8ee7) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x292a8ee7;
	} else {
		return inClassId==(int)0x2dd425b6;
	}
}

void ComponentGraphicsImpl_obj::setPixels( ::haxe::io::Bytes pixels){
            	HX_GC_STACKFRAME(&_hx_pos_401f586f6ef1a56f_15_setPixels)
HXLINE(  16)		if ((this->_hasSize == false)) {
HXLINE(  17)			this->super::setPixels(pixels);
HXDLIN(  17)			return;
            		}
HXLINE(  20)		int w = ::Std_obj::_hx_int(this->_component->get_width());
HXLINE(  21)		int h = ::Std_obj::_hx_int(this->_component->get_height());
HXLINE(  23)		if (::hx::IsNull( this->bitmapData )) {
HXLINE(  24)			this->bitmapData =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,w,h,true,0);
            		}
HXLINE(  28)		::Array< unsigned char > bytesData = pixels->b;
HXLINE(  29)		int length = pixels->length;
HXLINE(  30)		 ::haxe::io::Bytes newPixels = ::haxe::io::Bytes_obj::alloc(length);
HXLINE(  31)		int i = 0;
HXLINE(  32)		while((i < length)){
HXLINE(  33)			int r = ( (int)(_hx_array_unsafe_get(bytesData,i)) );
HXLINE(  34)			int g = ( (int)(_hx_array_unsafe_get(bytesData,(i + 1))) );
HXLINE(  35)			int b = ( (int)(_hx_array_unsafe_get(bytesData,(i + 2))) );
HXLINE(  36)			int a = ( (int)(_hx_array_unsafe_get(bytesData,(i + 3))) );
HXLINE(  37)			newPixels->b[i] = ( (unsigned char)(b) );
HXLINE(  38)			newPixels->b[(i + 1)] = ( (unsigned char)(g) );
HXLINE(  39)			newPixels->b[(i + 2)] = ( (unsigned char)(r) );
HXLINE(  40)			newPixels->b[(i + 3)] = ( (unsigned char)(a) );
HXLINE(  41)			i = (i + 4);
            		}
HXLINE(  43)		 ::openfl::utils::ByteArrayData byteArray = ::openfl::utils::_ByteArray::ByteArray_Impl__obj::fromBytes(newPixels);
HXLINE(  44)		 ::openfl::display::BitmapData _hx_tmp = this->bitmapData;
HXDLIN(  44)		_hx_tmp->setPixels( ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,this->bitmapData->width,this->bitmapData->height),byteArray);
HXLINE(  46)		if (::hx::IsNull( this->sprite )) {
HXLINE(  47)			this->sprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,0,null());
HXLINE(  48)			this->_component->add(this->sprite).StaticCast<  ::flixel::FlxSprite >();
            		}
HXLINE(  51)		this->sprite->set_width(( (Float)(w) ));
HXLINE(  52)		this->sprite->set_height(( (Float)(h) ));
HXLINE(  54)		this->sprite->set_pixels(this->bitmapData);
            	}


void ComponentGraphicsImpl_obj::resize( ::Dynamic width, ::Dynamic height){
            	HX_STACKFRAME(&_hx_pos_401f586f6ef1a56f_58_resize)
HXDLIN(  58)		bool _hx_tmp;
HXDLIN(  58)		if (::hx::IsGreater( width,0 )) {
HXDLIN(  58)			_hx_tmp = ::hx::IsGreater( height,0 );
            		}
            		else {
HXDLIN(  58)			_hx_tmp = false;
            		}
HXDLIN(  58)		if (_hx_tmp) {
HXLINE(  59)			if ((this->_hasSize == false)) {
HXLINE(  60)				this->_hasSize = true;
HXLINE(  61)				this->replayDrawCommands();
            			}
            		}
            	}



::hx::ObjectPtr< ComponentGraphicsImpl_obj > ComponentGraphicsImpl_obj::__new( ::haxe::ui::core::Component component) {
	::hx::ObjectPtr< ComponentGraphicsImpl_obj > __this = new ComponentGraphicsImpl_obj();
	__this->__construct(component);
	return __this;
}

::hx::ObjectPtr< ComponentGraphicsImpl_obj > ComponentGraphicsImpl_obj::__alloc(::hx::Ctx *_hx_ctx, ::haxe::ui::core::Component component) {
	ComponentGraphicsImpl_obj *__this = (ComponentGraphicsImpl_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ComponentGraphicsImpl_obj), true, "haxe.ui.backend.ComponentGraphicsImpl"));
	*(void **)__this = ComponentGraphicsImpl_obj::_hx_vtable;
	__this->__construct(component);
	return __this;
}

ComponentGraphicsImpl_obj::ComponentGraphicsImpl_obj()
{
}

void ComponentGraphicsImpl_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ComponentGraphicsImpl);
	HX_MARK_MEMBER_NAME(_hasSize,"_hasSize");
	HX_MARK_MEMBER_NAME(bitmapData,"bitmapData");
	HX_MARK_MEMBER_NAME(sprite,"sprite");
	 ::haxe::ui::backend::ComponentGraphicsBase_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ComponentGraphicsImpl_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hasSize,"_hasSize");
	HX_VISIT_MEMBER_NAME(bitmapData,"bitmapData");
	HX_VISIT_MEMBER_NAME(sprite,"sprite");
	 ::haxe::ui::backend::ComponentGraphicsBase_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ComponentGraphicsImpl_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sprite") ) { return ::hx::Val( sprite ); }
		if (HX_FIELD_EQ(inName,"resize") ) { return ::hx::Val( resize_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_hasSize") ) { return ::hx::Val( _hasSize ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setPixels") ) { return ::hx::Val( setPixels_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { return ::hx::Val( bitmapData ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ComponentGraphicsImpl_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sprite") ) { sprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_hasSize") ) { _hasSize=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { bitmapData=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ComponentGraphicsImpl_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_hasSize",bc,1a,50,55));
	outFields->push(HX_("bitmapData",b9,b5,c0,33));
	outFields->push(HX_("sprite",05,dc,95,c3));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ComponentGraphicsImpl_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(ComponentGraphicsImpl_obj,_hasSize),HX_("_hasSize",bc,1a,50,55)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(ComponentGraphicsImpl_obj,bitmapData),HX_("bitmapData",b9,b5,c0,33)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(ComponentGraphicsImpl_obj,sprite),HX_("sprite",05,dc,95,c3)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ComponentGraphicsImpl_obj_sStaticStorageInfo = 0;
#endif

static ::String ComponentGraphicsImpl_obj_sMemberFields[] = {
	HX_("_hasSize",bc,1a,50,55),
	HX_("bitmapData",b9,b5,c0,33),
	HX_("sprite",05,dc,95,c3),
	HX_("setPixels",6f,64,51,ec),
	HX_("resize",f4,59,7b,08),
	::String(null()) };

::hx::Class ComponentGraphicsImpl_obj::__mClass;

void ComponentGraphicsImpl_obj::__register()
{
	ComponentGraphicsImpl_obj _hx_dummy;
	ComponentGraphicsImpl_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.backend.ComponentGraphicsImpl",5c,c7,44,c8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ComponentGraphicsImpl_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ComponentGraphicsImpl_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ComponentGraphicsImpl_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ComponentGraphicsImpl_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ui
} // end namespace backend
