// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif
#ifndef INCLUDED_openfl_display__internal__Context3DGraphics_PolygonFunctions
#include <openfl/display/_internal/_Context3DGraphics/PolygonFunctions.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_3de7e0c4b00a9c15_1294_getEllipseNumVertices,"openfl.display._internal._Context3DGraphics.PolygonFunctions","getEllipseNumVertices",0xdbd874b0,"openfl.display._internal._Context3DGraphics.PolygonFunctions.getEllipseNumVertices","openfl/display/_internal/Context3DGraphics.hx",1294,0x8e8e2a52)
HX_LOCAL_STACK_FRAME(_hx_pos_3de7e0c4b00a9c15_1305_buildEllipseVerticesAndIndices,"openfl.display._internal._Context3DGraphics.PolygonFunctions","buildEllipseVerticesAndIndices",0x1334fc60,"openfl.display._internal._Context3DGraphics.PolygonFunctions.buildEllipseVerticesAndIndices","openfl/display/_internal/Context3DGraphics.hx",1305,0x8e8e2a52)
HX_LOCAL_STACK_FRAME(_hx_pos_3de7e0c4b00a9c15_1331_getRoundRectNumVertices,"openfl.display._internal._Context3DGraphics.PolygonFunctions","getRoundRectNumVertices",0x373ffb3c,"openfl.display._internal._Context3DGraphics.PolygonFunctions.getRoundRectNumVertices","openfl/display/_internal/Context3DGraphics.hx",1331,0x8e8e2a52)
HX_LOCAL_STACK_FRAME(_hx_pos_3de7e0c4b00a9c15_1342_buildRoundRectVerticesAndIndices,"openfl.display._internal._Context3DGraphics.PolygonFunctions","buildRoundRectVerticesAndIndices",0xd67b7954,"openfl.display._internal._Context3DGraphics.PolygonFunctions.buildRoundRectVerticesAndIndices","openfl/display/_internal/Context3DGraphics.hx",1342,0x8e8e2a52)
namespace openfl{
namespace display{
namespace _internal{
namespace _Context3DGraphics{

void PolygonFunctions_obj::__construct() { }

Dynamic PolygonFunctions_obj::__CreateEmpty() { return new PolygonFunctions_obj; }

void *PolygonFunctions_obj::_hx_vtable = 0;

Dynamic PolygonFunctions_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PolygonFunctions_obj > _hx_result = new PolygonFunctions_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PolygonFunctions_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x12451c77;
}

int PolygonFunctions_obj::getEllipseNumVertices(Float radiusX,Float radiusY){
            	HX_STACKFRAME(&_hx_pos_3de7e0c4b00a9c15_1294_getEllipseNumVertices)
HXLINE(1295)		int numVertices = ::Std_obj::_hx_int(((::Math_obj::PI * (radiusX + radiusY)) / ((Float)4.0)));
HXLINE(1296)		if ((numVertices < 6)) {
HXLINE(1298)			numVertices = 6;
            		}
HXLINE(1300)		return numVertices;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(PolygonFunctions_obj,getEllipseNumVertices,return )

void PolygonFunctions_obj::buildEllipseVerticesAndIndices(Float x,Float y,Float radiusX,Float radiusY,Float scaleX,Float scaleY, ::openfl::_Vector::FloatVector vertices, ::openfl::_Vector::IntVector indices){
            	HX_STACKFRAME(&_hx_pos_3de7e0c4b00a9c15_1305_buildEllipseVerticesAndIndices)
HXLINE(1306)		int numVertices = ::Std_obj::_hx_int(((::Math_obj::PI * ((radiusX * scaleX) + (radiusY * scaleY))) / ((Float)4.0)));
HXDLIN(1306)		if ((numVertices < 6)) {
HXLINE(1306)			numVertices = 6;
            		}
HXDLIN(1306)		int numVertices1 = numVertices;
HXLINE(1308)		Float angleDelta = ((((Float)2.0) * ::Math_obj::PI) / ( (Float)(numVertices1) ));
HXLINE(1309)		Float angle = ((Float)0.0);
HXLINE(1311)		vertices->set_length((numVertices1 * 2));
HXLINE(1312)		{
HXLINE(1312)			int _g = 0;
HXDLIN(1312)			int _g1 = numVertices1;
HXDLIN(1312)			while((_g < _g1)){
HXLINE(1312)				_g = (_g + 1);
HXDLIN(1312)				int i = (_g - 1);
HXLINE(1314)				vertices->set((i * 2),(((::Math_obj::cos(angle) * radiusX) + x) + radiusX));
HXLINE(1315)				vertices->set(((i * 2) + 1),(((::Math_obj::sin(angle) * radiusY) + y) + radiusY));
HXLINE(1316)				angle = (angle + angleDelta);
            			}
            		}
HXLINE(1319)		indices->set_length(((numVertices1 - 2) * 3));
HXLINE(1320)		int from = 0;
HXLINE(1321)		int to = (numVertices1 - 2);
HXLINE(1322)		{
HXLINE(1322)			int _g2 = from;
HXDLIN(1322)			int _g3 = to;
HXDLIN(1322)			while((_g2 < _g3)){
HXLINE(1322)				_g2 = (_g2 + 1);
HXDLIN(1322)				int i1 = (_g2 - 1);
HXLINE(1324)				indices->set((i1 * 3),0);
HXLINE(1325)				indices->set(((i1 * 3) + 1),(i1 + 1));
HXLINE(1326)				indices->set(((i1 * 3) + 2),(i1 + 2));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(PolygonFunctions_obj,buildEllipseVerticesAndIndices,(void))

int PolygonFunctions_obj::getRoundRectNumVertices(Float radiusX,Float radiusY){
            	HX_STACKFRAME(&_hx_pos_3de7e0c4b00a9c15_1331_getRoundRectNumVertices)
HXLINE(1332)		int numVerticesPerCorner = ::Math_obj::ceil(((::Math_obj::PI * (radiusX + radiusY)) / ((Float)8.0)));
HXLINE(1333)		if ((numVerticesPerCorner < 3)) {
HXLINE(1335)			numVerticesPerCorner = 3;
            		}
HXLINE(1337)		return (numVerticesPerCorner * 4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(PolygonFunctions_obj,getRoundRectNumVertices,return )

void PolygonFunctions_obj::buildRoundRectVerticesAndIndices(Float x,Float y,Float width,Float height,Float radiusX,Float radiusY,Float scaleX,Float scaleY, ::openfl::_Vector::FloatVector vertices, ::openfl::_Vector::IntVector indices){
            	HX_STACKFRAME(&_hx_pos_3de7e0c4b00a9c15_1342_buildRoundRectVerticesAndIndices)
HXLINE(1343)		int numVerticesPerCorner = ::Math_obj::ceil(((::Math_obj::PI * ((radiusX * scaleX) + (radiusY * scaleY))) / ((Float)8.0)));
HXDLIN(1343)		if ((numVerticesPerCorner < 3)) {
HXLINE(1343)			numVerticesPerCorner = 3;
            		}
HXDLIN(1343)		int numVertices = (numVerticesPerCorner * 4);
HXLINE(1344)		int verticesPerCorner = ::Std_obj::_hx_int((( (Float)(numVertices) ) / ( (Float)(4) )));
HXLINE(1346)		Float angleDelta = ((::Math_obj::PI / ((Float)2.0)) / ( (Float)((verticesPerCorner - 1)) ));
HXLINE(1347)		Float angle = ((Float)0.0);
HXLINE(1348)		Float offsetX = ((width - radiusX) - radiusX);
HXLINE(1349)		Float offsetY = ((height - radiusY) - radiusY);
HXLINE(1350)		bool horizontal = true;
HXLINE(1352)		vertices->set_length((numVertices * 2));
HXLINE(1353)		int j = 0;
HXLINE(1354)		int len = verticesPerCorner;
HXLINE(1355)		{
HXLINE(1355)			int _g = 0;
HXDLIN(1355)			while((_g < 4)){
HXLINE(1355)				_g = (_g + 1);
HXDLIN(1355)				int i = (_g - 1);
HXLINE(1357)				while((j < len)){
HXLINE(1359)					vertices->set((j * 2),(((offsetX + (::Math_obj::cos(angle) * radiusX)) + x) + radiusX));
HXLINE(1360)					vertices->set(((j * 2) + 1),(((offsetY + (::Math_obj::sin(angle) * radiusY)) + y) + radiusY));
HXLINE(1361)					angle = (angle + angleDelta);
HXLINE(1362)					j = (j + 1);
            				}
HXLINE(1364)				angle = (angle - angleDelta);
HXLINE(1365)				if (horizontal) {
HXLINE(1367)					if ((offsetX == ((Float)0.0))) {
HXLINE(1369)						offsetX = ((width - radiusX) - radiusX);
            					}
            					else {
HXLINE(1373)						offsetX = ((Float)0.0);
            					}
            				}
            				else {
HXLINE(1378)					if ((offsetY == ((Float)0.0))) {
HXLINE(1380)						offsetY = ((height - radiusY) - radiusY);
            					}
            					else {
HXLINE(1384)						offsetY = ((Float)0.0);
            					}
            				}
HXLINE(1387)				horizontal = !(horizontal);
HXLINE(1388)				len = (len + verticesPerCorner);
            			}
            		}
HXLINE(1391)		indices->set_length(((numVertices - 2) * 3));
HXLINE(1392)		int from = 0;
HXLINE(1393)		int to = (numVertices - 2);
HXLINE(1394)		{
HXLINE(1394)			int _g1 = from;
HXDLIN(1394)			int _g2 = to;
HXDLIN(1394)			while((_g1 < _g2)){
HXLINE(1394)				_g1 = (_g1 + 1);
HXDLIN(1394)				int i1 = (_g1 - 1);
HXLINE(1396)				indices->set((i1 * 3),0);
HXLINE(1397)				indices->set(((i1 * 3) + 1),(i1 + 1));
HXLINE(1398)				indices->set(((i1 * 3) + 2),(i1 + 2));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(PolygonFunctions_obj,buildRoundRectVerticesAndIndices,(void))


PolygonFunctions_obj::PolygonFunctions_obj()
{
}

bool PolygonFunctions_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 21:
		if (HX_FIELD_EQ(inName,"getEllipseNumVertices") ) { outValue = getEllipseNumVertices_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"getRoundRectNumVertices") ) { outValue = getRoundRectNumVertices_dyn(); return true; }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"buildEllipseVerticesAndIndices") ) { outValue = buildEllipseVerticesAndIndices_dyn(); return true; }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"buildRoundRectVerticesAndIndices") ) { outValue = buildRoundRectVerticesAndIndices_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PolygonFunctions_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PolygonFunctions_obj_sStaticStorageInfo = 0;
#endif

::hx::Class PolygonFunctions_obj::__mClass;

static ::String PolygonFunctions_obj_sStaticFields[] = {
	HX_("getEllipseNumVertices",57,fa,1b,af),
	HX_("buildEllipseVerticesAndIndices",d9,09,6d,60),
	HX_("getRoundRectNumVertices",a3,78,ad,06),
	HX_("buildRoundRectVerticesAndIndices",0d,97,ec,eb),
	::String(null())
};

void PolygonFunctions_obj::__register()
{
	PolygonFunctions_obj _hx_dummy;
	PolygonFunctions_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("openfl.display._internal._Context3DGraphics.PolygonFunctions",07,a0,8f,84);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PolygonFunctions_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PolygonFunctions_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< PolygonFunctions_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PolygonFunctions_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PolygonFunctions_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace display
} // end namespace _internal
} // end namespace _Context3DGraphics
