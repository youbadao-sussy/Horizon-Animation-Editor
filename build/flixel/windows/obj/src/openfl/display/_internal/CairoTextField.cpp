// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_Cairo
#include <lime/graphics/cairo/Cairo.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_CairoGlyph
#include <lime/graphics/cairo/CairoGlyph.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFTFontFace_CairoFTFontFace_Impl_
#include <lime/graphics/cairo/_CairoFTFontFace/CairoFTFontFace_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFontOptions_CairoFontOptions_Impl_
#include <lime/graphics/cairo/_CairoFontOptions/CairoFontOptions_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoImageSurface_CairoImageSurface_Impl_
#include <lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoPattern_CairoPattern_Impl_
#include <lime/graphics/cairo/_CairoPattern/CairoPattern_Impl_.h>
#endif
#ifndef INCLUDED_lime_math_Vector2
#include <lime/math/Vector2.h>
#endif
#ifndef INCLUDED_lime_text_Font
#include <lime/text/Font.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool
#include <lime/utils/ObjectPool.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_ObjectVector
#include <openfl/_Vector/ObjectVector.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_CairoRenderer
#include <openfl/display/CairoRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectRenderer
#include <openfl/display/DisplayObjectRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display__internal_CairoDisplayObject
#include <openfl/display/_internal/CairoDisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display__internal_CairoGraphics
#include <openfl/display/_internal/CairoGraphics.h>
#endif
#ifndef INCLUDED_openfl_display__internal_CairoTextField
#include <openfl/display/_internal/CairoTextField.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_text_Font
#include <openfl/text/Font.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif
#ifndef INCLUDED_openfl_text_TextFormat
#include <openfl/text/TextFormat.h>
#endif
#ifndef INCLUDED_openfl_text__internal_GlyphPosition
#include <openfl/text/_internal/GlyphPosition.h>
#endif
#ifndef INCLUDED_openfl_text__internal_TextEngine
#include <openfl/text/_internal/TextEngine.h>
#endif
#ifndef INCLUDED_openfl_text__internal_TextLayoutGroup
#include <openfl/text/_internal/TextLayoutGroup.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_a654946cfcca811d_34_render,"openfl.display._internal.CairoTextField","render",0x63933503,"openfl.display._internal.CairoTextField.render","openfl/display/_internal/CairoTextField.hx",34,0xd777675a)
HX_LOCAL_STACK_FRAME(_hx_pos_a654946cfcca811d_516_renderDrawable,"openfl.display._internal.CairoTextField","renderDrawable",0x65cf17c1,"openfl.display._internal.CairoTextField.renderDrawable","openfl/display/_internal/CairoTextField.hx",516,0xd777675a)
HX_LOCAL_STACK_FRAME(_hx_pos_a654946cfcca811d_536_renderDrawableMask,"openfl.display._internal.CairoTextField","renderDrawableMask",0x842bf94d,"openfl.display._internal.CairoTextField.renderDrawableMask","openfl/display/_internal/CairoTextField.hx",536,0xd777675a)
HX_LOCAL_STACK_FRAME(_hx_pos_a654946cfcca811d_31_boot,"openfl.display._internal.CairoTextField","boot",0x2185989f,"openfl.display._internal.CairoTextField.boot","openfl/display/_internal/CairoTextField.hx",31,0xd777675a)
namespace openfl{
namespace display{
namespace _internal{

void CairoTextField_obj::__construct() { }

Dynamic CairoTextField_obj::__CreateEmpty() { return new CairoTextField_obj; }

void *CairoTextField_obj::_hx_vtable = 0;

Dynamic CairoTextField_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CairoTextField_obj > _hx_result = new CairoTextField_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CairoTextField_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6fd3cbef;
}

void CairoTextField_obj::render( ::openfl::text::TextField textField, ::openfl::display::CairoRenderer renderer, ::openfl::geom::Matrix transform){
            	HX_GC_STACKFRAME(&_hx_pos_a654946cfcca811d_34_render)
HXLINE(  36)		 ::openfl::text::_internal::TextEngine textEngine = textField->_hx___textEngine;
HXLINE(  39)		bool useTextBounds;
HXDLIN(  39)		if (!(textEngine->background)) {
HXLINE(  39)			useTextBounds = textEngine->border;
            		}
            		else {
HXLINE(  39)			useTextBounds = true;
            		}
HXDLIN(  39)		bool useTextBounds1 = !(useTextBounds);
HXLINE(  40)		 ::openfl::geom::Rectangle bounds;
HXDLIN(  40)		if (useTextBounds1) {
HXLINE(  40)			bounds = textEngine->textBounds;
            		}
            		else {
HXLINE(  40)			bounds = textEngine->bounds;
            		}
HXLINE(  41)		 ::openfl::display::Graphics graphics = textField->_hx___graphics;
HXLINE(  42)		 ::lime::graphics::cairo::Cairo cairo = graphics->_hx___cairo;
HXLINE(  43)		Float cursorOffsetX = ((Float)0.0);
HXLINE(  45)		if (textField->_hx___dirty) {
HXLINE(  47)			textField->_hx___updateLayout();
HXLINE(  49)			if (::hx::IsNull( graphics->_hx___bounds )) {
HXLINE(  51)				graphics->_hx___bounds =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXLINE(  54)			if ((textField->get_text().length == 0)) {
HXLINE(  56)				Float boundsWidth = (textEngine->bounds->width - ( (Float)(4) ));
HXLINE(  57)				 ::Dynamic align = textField->get_defaultTextFormat()->align;
HXLINE(  58)				if (::hx::IsEq( align,3 )) {
HXLINE(  58)					cursorOffsetX = ( (Float)(0) );
            				}
            				else {
HXLINE(  58)					if (::hx::IsEq( align,4 )) {
HXLINE(  58)						cursorOffsetX = boundsWidth;
            					}
            					else {
HXLINE(  58)						cursorOffsetX = (boundsWidth / ( (Float)(2) ));
            					}
            				}
HXLINE(  59)				 ::Dynamic _hx_switch_0 = align;
            				if (  (_hx_switch_0==0) ){
HXLINE(  68)					cursorOffsetX = (cursorOffsetX + (( (Float)(textField->get_defaultTextFormat()->leftMargin) ) / ( (Float)(2) )));
HXLINE(  69)					cursorOffsetX = (cursorOffsetX - (( (Float)(textField->get_defaultTextFormat()->rightMargin) ) / ( (Float)(2) )));
HXLINE(  70)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->indent);
HXLINE(  71)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->blockIndent);
HXLINE(  67)					goto _hx_goto_0;
            				}
            				if (  (_hx_switch_0==1) ){
HXLINE(  78)					goto _hx_goto_0;
            				}
            				if (  (_hx_switch_0==2) ){
HXLINE(  75)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->leftMargin);
HXLINE(  76)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->indent);
HXLINE(  77)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->blockIndent);
HXLINE(  74)					goto _hx_goto_0;
            				}
            				if (  (_hx_switch_0==3) ){
HXLINE(  62)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->leftMargin);
HXLINE(  63)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->indent);
HXLINE(  64)					cursorOffsetX = (cursorOffsetX + textField->get_defaultTextFormat()->blockIndent);
HXLINE(  61)					goto _hx_goto_0;
            				}
            				if (  (_hx_switch_0==4) ){
HXLINE(  66)					cursorOffsetX = (cursorOffsetX - ( (Float)(textField->get_defaultTextFormat()->rightMargin) ));
HXDLIN(  66)					goto _hx_goto_0;
            				}
            				if (  (_hx_switch_0==5) ){
HXLINE(  72)					goto _hx_goto_0;
            				}
            				_hx_goto_0:;
HXLINE(  81)				if (useTextBounds1) {
HXLINE(  83)					bounds->y = textEngine->bounds->y;
HXLINE(  84)					bounds->x = cursorOffsetX;
            				}
            			}
HXLINE(  88)			graphics->_hx___bounds->copyFrom(bounds);
            		}
HXLINE(  97)		Float pixelRatio = renderer->_hx___pixelRatio;
HXLINE( 100)		graphics->_hx___update(renderer->_hx___worldTransform,pixelRatio);
HXLINE( 102)		int width = ::Math_obj::round((( (Float)(graphics->_hx___width) ) * pixelRatio));
HXLINE( 103)		int height = ::Math_obj::round((( (Float)(graphics->_hx___height) ) * pixelRatio));
HXLINE( 105)		bool renderable;
HXDLIN( 105)		bool renderable1;
HXDLIN( 105)		if (!(textEngine->border)) {
HXLINE( 105)			renderable1 = textEngine->background;
            		}
            		else {
HXLINE( 105)			renderable1 = true;
            		}
HXDLIN( 105)		if (!(renderable1)) {
HXLINE( 105)			renderable = ::hx::IsNotNull( textEngine->text );
            		}
            		else {
HXLINE( 105)			renderable = true;
            		}
HXLINE( 106)		bool needsUpscaling = false;
HXLINE( 108)		if (::hx::IsNotNull( cairo )) {
HXLINE( 111)			 ::Dynamic surface = graphics->_hx___bitmap->getSurface();
HXLINE( 113)			bool _hx_tmp;
HXDLIN( 113)			if (graphics->_hx___softwareDirty) {
HXLINE( 113)				if ((width <= ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_width(surface))) {
HXLINE( 113)					_hx_tmp = (height > ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_height(surface));
            				}
            				else {
HXLINE( 113)					_hx_tmp = true;
            				}
            			}
            			else {
HXLINE( 113)				_hx_tmp = false;
            			}
HXDLIN( 113)			if (_hx_tmp) {
HXLINE( 115)				needsUpscaling = true;
            			}
HXLINE( 118)			bool _hx_tmp1;
HXDLIN( 118)			if (renderable) {
HXLINE( 118)				_hx_tmp1 = needsUpscaling;
            			}
            			else {
HXLINE( 118)				_hx_tmp1 = true;
            			}
HXDLIN( 118)			if (_hx_tmp1) {
HXLINE( 120)				graphics->_hx___cairo = null();
HXLINE( 121)				graphics->_hx___bitmap = null();
HXLINE( 122)				graphics->_hx___visible = false;
HXLINE( 123)				cairo = null();
            			}
            		}
HXLINE( 127)		bool _hx_tmp2;
HXDLIN( 127)		bool _hx_tmp3;
HXDLIN( 127)		bool _hx_tmp4;
HXDLIN( 127)		if ((width > 0)) {
HXLINE( 127)			_hx_tmp4 = (height <= 0);
            		}
            		else {
HXLINE( 127)			_hx_tmp4 = true;
            		}
HXDLIN( 127)		if (!(_hx_tmp4)) {
HXLINE( 129)			bool _hx_tmp5;
HXDLIN( 129)			if (!(textField->_hx___dirty)) {
HXLINE( 129)				_hx_tmp5 = !(graphics->_hx___softwareDirty);
            			}
            			else {
HXLINE( 129)				_hx_tmp5 = false;
            			}
HXDLIN( 129)			if (_hx_tmp5) {
HXLINE( 129)				if (graphics->_hx___visible) {
HXLINE( 127)					_hx_tmp3 = ::hx::IsNotNull( graphics->_hx___bitmap );
            				}
            				else {
HXLINE( 127)					_hx_tmp3 = true;
            				}
            			}
            			else {
HXLINE( 127)				_hx_tmp3 = false;
            			}
            		}
            		else {
HXLINE( 127)			_hx_tmp3 = true;
            		}
HXDLIN( 127)		if (!(_hx_tmp3)) {
HXLINE( 127)			_hx_tmp2 = !(renderable);
            		}
            		else {
HXLINE( 127)			_hx_tmp2 = true;
            		}
HXDLIN( 127)		if (_hx_tmp2) {
HXLINE( 132)			textField->_hx___dirty = false;
HXLINE( 133)			return;
            		}
HXLINE( 136)		if (::hx::IsNull( cairo )) {
HXLINE( 138)			int bitmapWidth;
HXDLIN( 138)			if (needsUpscaling) {
HXLINE( 138)				bitmapWidth = ::Std_obj::_hx_int((( (Float)(width) ) * ((Float)1.25)));
            			}
            			else {
HXLINE( 138)				bitmapWidth = width;
            			}
HXLINE( 139)			int bitmapHeight;
HXDLIN( 139)			if (needsUpscaling) {
HXLINE( 139)				bitmapHeight = ::Std_obj::_hx_int((( (Float)(height) ) * ((Float)1.25)));
            			}
            			else {
HXLINE( 139)				bitmapHeight = height;
            			}
HXLINE( 141)			bool _hx_tmp6;
HXDLIN( 141)			if (::hx::IsNotNull( ::openfl::display::Graphics_obj::maxTextureWidth )) {
HXLINE( 141)				_hx_tmp6 = ::hx::IsGreater( bitmapWidth,::openfl::display::Graphics_obj::maxTextureWidth );
            			}
            			else {
HXLINE( 141)				_hx_tmp6 = false;
            			}
HXDLIN( 141)			if (_hx_tmp6) {
HXLINE( 143)				bitmapWidth = ( (int)(::openfl::display::Graphics_obj::maxTextureWidth) );
            			}
HXLINE( 146)			bool _hx_tmp7;
HXDLIN( 146)			if (::hx::IsNotNull( ::openfl::display::Graphics_obj::maxTextureHeight )) {
HXLINE( 146)				_hx_tmp7 = ::hx::IsGreater( bitmapHeight,::openfl::display::Graphics_obj::maxTextureHeight );
            			}
            			else {
HXLINE( 146)				_hx_tmp7 = false;
            			}
HXDLIN( 146)			if (_hx_tmp7) {
HXLINE( 148)				bitmapHeight = ( (int)(::openfl::display::Graphics_obj::maxTextureHeight) );
            			}
HXLINE( 151)			 ::openfl::display::BitmapData bitmap =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,bitmapWidth,bitmapHeight,true,0);
HXLINE( 152)			 ::Dynamic surface1 = bitmap->getSurface();
HXLINE( 153)			graphics->_hx___cairo =  ::lime::graphics::cairo::Cairo_obj::__alloc( HX_CTX ,surface1);
HXLINE( 154)			graphics->_hx___visible = true;
HXLINE( 155)			graphics->_hx___managed = true;
HXLINE( 157)			graphics->_hx___bitmap = bitmap;
HXLINE( 158)			graphics->_hx___bitmapScaleX = pixelRatio;
HXLINE( 159)			graphics->_hx___bitmapScaleY = pixelRatio;
HXLINE( 161)			cairo = graphics->_hx___cairo;
            		}
            		else {
HXLINE( 165)			cairo->identityMatrix();
HXLINE( 166)			cairo->resetClip();
HXLINE( 168)			cairo->setOperator(0);
HXLINE( 169)			cairo->paint();
HXLINE( 170)			cairo->setOperator(2);
            		}
HXLINE( 173)		 ::Dynamic options = ::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::_new();
HXLINE( 175)		bool _hx_tmp8;
HXDLIN( 175)		if (::hx::IsEq( textEngine->antiAliasType,0 )) {
HXLINE( 175)			_hx_tmp8 = (textEngine->sharpness == 400);
            		}
            		else {
HXLINE( 175)			_hx_tmp8 = false;
            		}
HXDLIN( 175)		if (_hx_tmp8) {
HXLINE( 177)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,1);
HXLINE( 178)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,1);
HXLINE( 179)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,1);
            		}
            		else {
HXLINE( 183)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,2);
HXLINE( 184)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,1);
HXLINE( 185)			::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,5);
            		}
HXLINE( 188)		cairo->set_fontOptions(options);
HXLINE( 190)		 ::openfl::geom::Matrix matrix = ::openfl::geom::Matrix_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Matrix >();
HXLINE( 191)		matrix->copyFrom(graphics->_hx___renderTransform);
HXLINE( 192)		matrix->scale(pixelRatio,pixelRatio);
HXLINE( 194)		renderer->applyMatrix(matrix,cairo);
HXLINE( 196)		::openfl::geom::Matrix_obj::_hx___pool->release(matrix);
HXLINE( 198)		if (textEngine->border) {
HXLINE( 200)			int _hx_tmp9 = ::Std_obj::_hx_int((bounds->width - ( (Float)(1) )));
HXDLIN( 200)			cairo->rectangle(((Float)0.5),((Float)0.5),( (Float)(_hx_tmp9) ),( (Float)(::Std_obj::_hx_int((bounds->height - ( (Float)(1) )))) ));
            		}
            		else {
HXLINE( 204)			cairo->rectangle(( (Float)(0) ),( (Float)(0) ),bounds->width,bounds->height);
            		}
HXLINE( 207)		if (textEngine->background) {
HXLINE( 209)			int color = textEngine->backgroundColor;
HXLINE( 210)			Float r = (( (Float)(::hx::UShr((color & 16711680),16)) ) / ( (Float)(255) ));
HXLINE( 211)			Float g = (( (Float)(::hx::UShr((color & 65280),8)) ) / ( (Float)(255) ));
HXLINE( 212)			Float b = (( (Float)((color & 255)) ) / ( (Float)(255) ));
HXLINE( 214)			cairo->setSourceRGB(r,g,b);
HXLINE( 215)			cairo->fillPreserve();
            		}
HXLINE( 218)		if (textEngine->border) {
HXLINE( 220)			int color1 = textEngine->borderColor;
HXLINE( 221)			Float r1 = (( (Float)(::hx::UShr((color1 & 16711680),16)) ) / ( (Float)(255) ));
HXLINE( 222)			Float g1 = (( (Float)(::hx::UShr((color1 & 65280),8)) ) / ( (Float)(255) ));
HXLINE( 223)			Float b1 = (( (Float)((color1 & 255)) ) / ( (Float)(255) ));
HXLINE( 225)			cairo->setSourceRGB(r1,g1,b1);
HXLINE( 226)			cairo->set_lineWidth(( (Float)(1) ));
HXLINE( 227)			cairo->stroke();
            		}
HXLINE( 230)		bool _hx_tmp10;
HXDLIN( 230)		if (::hx::IsNotNull( textEngine->text )) {
HXLINE( 230)			_hx_tmp10 = (textEngine->text != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 230)			_hx_tmp10 = false;
            		}
HXDLIN( 230)		if (_hx_tmp10) {
HXLINE( 232)			Float bounds1 = bounds->width;
HXDLIN( 232)			int _hx_tmp11;
HXDLIN( 232)			if (textField->get_border()) {
HXLINE( 232)				_hx_tmp11 = 1;
            			}
            			else {
HXLINE( 232)				_hx_tmp11 = 0;
            			}
HXDLIN( 232)			Float bounds2 = bounds->height;
HXDLIN( 232)			int _hx_tmp12;
HXDLIN( 232)			if (textField->get_border()) {
HXLINE( 232)				_hx_tmp12 = 1;
            			}
            			else {
HXLINE( 232)				_hx_tmp12 = 0;
            			}
HXDLIN( 232)			cairo->rectangle(( (Float)(0) ),( (Float)(0) ),(bounds1 - ( (Float)(_hx_tmp11) )),(bounds2 - ( (Float)(_hx_tmp12) )));
HXLINE( 233)			cairo->clip();
HXLINE( 235)			::String text = textEngine->text;
HXLINE( 237)			int scrollX = -(textField->get_scrollH());
HXLINE( 238)			Float scrollY = ((Float)0.0);
HXLINE( 240)			{
HXLINE( 240)				int _g = 0;
HXDLIN( 240)				int _g1 = (textField->get_scrollV() - 1);
HXDLIN( 240)				while((_g < _g1)){
HXLINE( 240)					_g = (_g + 1);
HXDLIN( 240)					int i = (_g - 1);
HXLINE( 242)					scrollY = (scrollY - textEngine->lineHeights->get(i));
            				}
            			}
HXLINE( 245)			int color2;
HXLINE( 246)			Float r2;
HXLINE( 247)			Float g2;
HXLINE( 248)			Float b2;
HXLINE( 249)			 ::openfl::text::Font font;
HXLINE( 250)			int size;
HXLINE( 251)			Float advance;
HXLINE( 253)			{
HXLINE( 253)				 ::Dynamic group = textEngine->layoutGroups->iterator();
HXDLIN( 253)				while(( (bool)(group->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 253)					 ::openfl::text::_internal::TextLayoutGroup group1 = ( ( ::openfl::text::_internal::TextLayoutGroup)(group->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 255)					int group2 = group1->lineIndex;
HXDLIN( 255)					if ((group2 < (textField->get_scrollV() - 1))) {
HXLINE( 255)						continue;
            					}
HXLINE( 256)					int group3 = group1->lineIndex;
HXDLIN( 256)					if ((group3 > (textEngine->get_bottomScrollV() - 1))) {
HXLINE( 256)						goto _hx_goto_2;
            					}
HXLINE( 258)					color2 = ( (int)(group1->format->color) );
HXLINE( 259)					r2 = (( (Float)(::hx::UShr((color2 & 16711680),16)) ) / ( (Float)(255) ));
HXLINE( 260)					g2 = (( (Float)(::hx::UShr((color2 & 65280),8)) ) / ( (Float)(255) ));
HXLINE( 261)					b2 = (( (Float)((color2 & 255)) ) / ( (Float)(255) ));
HXLINE( 263)					cairo->setSourceRGB(r2,g2,b2);
HXLINE( 265)					font = ::openfl::text::_internal::TextEngine_obj::getFontInstance(group1->format);
HXLINE( 267)					bool _hx_tmp13;
HXDLIN( 267)					if (::hx::IsNotNull( font )) {
HXLINE( 267)						_hx_tmp13 = ::hx::IsNotNull( group1->format->size );
            					}
            					else {
HXLINE( 267)						_hx_tmp13 = false;
            					}
HXDLIN( 267)					if (_hx_tmp13) {
HXLINE( 269)						if (::hx::IsNotNull( textEngine->_hx___cairoFont )) {
HXLINE( 271)							if (::hx::IsInstanceNotEq( textEngine->_hx___font,font )) {
HXLINE( 273)								textEngine->_hx___cairoFont = null();
            							}
            						}
HXLINE( 277)						if (::hx::IsNull( textEngine->_hx___cairoFont )) {
HXLINE( 279)							textEngine->_hx___font = font;
HXLINE( 280)							textEngine->_hx___cairoFont = ::lime::graphics::cairo::_CairoFTFontFace::CairoFTFontFace_Impl__obj::create(font,0);
            						}
HXLINE( 283)						cairo->set_fontFace(textEngine->_hx___cairoFont);
HXLINE( 285)						size = ::Std_obj::_hx_int(( (Float)(group1->format->size) ));
HXLINE( 286)						cairo->setFontSize(( (Float)(size) ));
HXLINE( 288)						cairo->moveTo(((group1->offsetX + scrollX) - bounds->x),(((group1->offsetY + group1->ascent) + scrollY) - bounds->y));
HXLINE( 295)						cairo->translate(( (Float)(0) ),( (Float)(0) ));
HXLINE( 297)						::Array< ::Dynamic> glyphs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 298)						Float x = ((group1->offsetX + scrollX) - bounds->x);
HXLINE( 299)						Float y = (((group1->offsetY + group1->ascent) + scrollY) - bounds->y);
HXLINE( 301)						{
HXLINE( 301)							int _g2 = 0;
HXDLIN( 301)							::Array< ::Dynamic> _g3 = group1->positions;
HXDLIN( 301)							while((_g2 < _g3->length)){
HXLINE( 301)								 ::openfl::text::_internal::GlyphPosition position = _g3->__get(_g2).StaticCast<  ::openfl::text::_internal::GlyphPosition >();
HXDLIN( 301)								_g2 = (_g2 + 1);
HXLINE( 303)								bool _hx_tmp14;
HXDLIN( 303)								if (::hx::IsNotNull( position )) {
HXLINE( 303)									_hx_tmp14 = (position->glyph == 0);
            								}
            								else {
HXLINE( 303)									_hx_tmp14 = true;
            								}
HXDLIN( 303)								if (_hx_tmp14) {
HXLINE( 303)									continue;
            								}
HXLINE( 304)								glyphs->push( ::lime::graphics::cairo::CairoGlyph_obj::__alloc( HX_CTX ,position->glyph,((x + position->offset->x) + ((Float)0.5)),((y - position->offset->y) + ((Float)0.5))));
HXLINE( 305)								x = (x + position->advance->x);
HXLINE( 306)								y = (y - position->advance->y);
            							}
            						}
HXLINE( 309)						cairo->showGlyphs(glyphs);
HXLINE( 312)						bool _hx_tmp15;
HXDLIN( 312)						if ((textField->_hx___caretIndex > -1)) {
HXLINE( 312)							_hx_tmp15 = textEngine->selectable;
            						}
            						else {
HXLINE( 312)							_hx_tmp15 = false;
            						}
HXDLIN( 312)						if (_hx_tmp15) {
HXLINE( 314)							if ((textField->_hx___selectionIndex == textField->_hx___caretIndex)) {
HXLINE( 316)								bool _hx_tmp16;
HXDLIN( 316)								bool _hx_tmp17;
HXDLIN( 316)								if (textField->_hx___showCursor) {
HXLINE( 316)									_hx_tmp17 = (group1->startIndex <= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 316)									_hx_tmp17 = false;
            								}
HXDLIN( 316)								if (_hx_tmp17) {
HXLINE( 316)									_hx_tmp16 = (group1->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 316)									_hx_tmp16 = false;
            								}
HXDLIN( 316)								if (_hx_tmp16) {
HXLINE( 320)									advance = ((Float)0.0);
HXLINE( 322)									{
HXLINE( 322)										int _g4 = 0;
HXDLIN( 322)										int _g5 = (textField->_hx___caretIndex - group1->startIndex);
HXDLIN( 322)										while((_g4 < _g5)){
HXLINE( 322)											_g4 = (_g4 + 1);
HXDLIN( 322)											int i1 = (_g4 - 1);
HXLINE( 324)											if ((group1->positions->length <= i1)) {
HXLINE( 324)												goto _hx_goto_4;
            											}
HXLINE( 325)											Float advance1;
HXDLIN( 325)											bool advance2;
HXDLIN( 325)											if ((i1 >= 0)) {
HXLINE( 325)												advance2 = (i1 < group1->positions->length);
            											}
            											else {
HXLINE( 325)												advance2 = false;
            											}
HXDLIN( 325)											if (advance2) {
HXLINE( 325)												advance1 = group1->positions->__get(i1).StaticCast<  ::openfl::text::_internal::GlyphPosition >()->advance->x;
            											}
            											else {
HXLINE( 325)												advance1 = ( (Float)(0) );
            											}
HXDLIN( 325)											advance = (advance + advance1);
            										}
            										_hx_goto_4:;
            									}
HXLINE( 328)									Float scrollY1 = ((Float)0.0);
HXLINE( 330)									{
HXLINE( 330)										int _g6 = textField->get_scrollV();
HXDLIN( 330)										int _g7 = (group1->lineIndex + 1);
HXDLIN( 330)										while((_g6 < _g7)){
HXLINE( 330)											_g6 = (_g6 + 1);
HXDLIN( 330)											int i2 = (_g6 - 1);
HXLINE( 332)											scrollY1 = (scrollY1 + textEngine->lineHeights->get((i2 - 1)));
            										}
            									}
HXLINE( 335)									Float _hx_tmp18 = (::Math_obj::floor((group1->offsetX + advance)) + ((Float)0.5));
HXDLIN( 335)									Float _hx_tmp19 = (_hx_tmp18 - ( (Float)(textField->get_scrollH()) ));
HXDLIN( 335)									cairo->moveTo((_hx_tmp19 - bounds->x),((scrollY1 + ((Float)2.5)) - bounds->y));
HXLINE( 336)									cairo->set_lineWidth(( (Float)(1) ));
HXLINE( 337)									Float _hx_tmp20 = (::Math_obj::floor((group1->offsetX + advance)) + ((Float)0.5));
HXDLIN( 337)									Float _hx_tmp21 = (_hx_tmp20 - ( (Float)(textField->get_scrollH()) ));
HXDLIN( 337)									Float _hx_tmp22 = (_hx_tmp21 - bounds->x);
HXLINE( 341)									Float _hx_tmp23 = ((scrollY1 + ::openfl::text::_internal::TextEngine_obj::getFormatHeight(textField->get_defaultTextFormat())) - ( (Float)(1) ));
HXLINE( 337)									cairo->lineTo(_hx_tmp22,(_hx_tmp23 - bounds->y));
HXLINE( 345)									cairo->stroke();
            								}
            							}
            							else {
HXLINE( 348)								bool _hx_tmp24;
HXDLIN( 348)								bool _hx_tmp25;
HXDLIN( 348)								bool _hx_tmp26;
HXDLIN( 348)								bool _hx_tmp27;
HXDLIN( 348)								if ((group1->startIndex <= textField->_hx___caretIndex)) {
HXLINE( 348)									_hx_tmp27 = (group1->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 348)									_hx_tmp27 = false;
            								}
HXDLIN( 348)								if (!(_hx_tmp27)) {
HXLINE( 349)									if ((group1->startIndex <= textField->_hx___selectionIndex)) {
HXLINE( 348)										_hx_tmp26 = (group1->endIndex >= textField->_hx___selectionIndex);
            									}
            									else {
HXLINE( 348)										_hx_tmp26 = false;
            									}
            								}
            								else {
HXLINE( 348)									_hx_tmp26 = true;
            								}
HXDLIN( 348)								if (!(_hx_tmp26)) {
HXLINE( 350)									if ((group1->startIndex > textField->_hx___caretIndex)) {
HXLINE( 348)										_hx_tmp25 = (group1->endIndex < textField->_hx___selectionIndex);
            									}
            									else {
HXLINE( 348)										_hx_tmp25 = false;
            									}
            								}
            								else {
HXLINE( 348)									_hx_tmp25 = true;
            								}
HXDLIN( 348)								if (!(_hx_tmp25)) {
HXLINE( 351)									if ((group1->startIndex > textField->_hx___selectionIndex)) {
HXLINE( 348)										_hx_tmp24 = (group1->endIndex < textField->_hx___caretIndex);
            									}
            									else {
HXLINE( 348)										_hx_tmp24 = false;
            									}
            								}
            								else {
HXLINE( 348)									_hx_tmp24 = true;
            								}
HXDLIN( 348)								if (_hx_tmp24) {
HXLINE( 353)									int selectionStart = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(textField->_hx___selectionIndex) ),( (Float)(textField->_hx___caretIndex) )));
HXLINE( 354)									int selectionEnd = ::Std_obj::_hx_int(::Math_obj::max(( (Float)(textField->_hx___selectionIndex) ),( (Float)(textField->_hx___caretIndex) )));
HXLINE( 356)									if ((group1->startIndex > selectionStart)) {
HXLINE( 358)										selectionStart = group1->startIndex;
            									}
HXLINE( 361)									if ((group1->endIndex < selectionEnd)) {
HXLINE( 363)										selectionEnd = group1->endIndex;
            									}
HXLINE( 367)									 ::openfl::geom::Rectangle end;
HXLINE( 366)									 ::openfl::geom::Rectangle start = textField->getCharBoundaries(selectionStart);
HXLINE( 371)									if ((selectionEnd >= group1->endIndex)) {
HXLINE( 373)										end = textField->getCharBoundaries((group1->endIndex - 1));
HXLINE( 375)										if (::hx::IsNotNull( end )) {
HXLINE( 377)											 ::openfl::geom::Rectangle end1 = end;
HXDLIN( 377)											end1->x = (end1->x + (end->width + 2));
            										}
            									}
            									else {
HXLINE( 382)										end = textField->getCharBoundaries(selectionEnd);
            									}
HXLINE( 385)									bool _hx_tmp28;
HXDLIN( 385)									if (::hx::IsNotNull( start )) {
HXLINE( 385)										_hx_tmp28 = ::hx::IsNotNull( end );
            									}
            									else {
HXLINE( 385)										_hx_tmp28 = false;
            									}
HXDLIN( 385)									if (_hx_tmp28) {
HXLINE( 387)										cairo->setSourceRGB(( (Float)(0) ),( (Float)(0) ),( (Float)(0) ));
HXLINE( 388)										cairo->rectangle(((scrollX + start->x) - bounds->x),(start->y + scrollY),(end->x - start->x),group1->height);
HXLINE( 389)										cairo->fill();
HXLINE( 390)										cairo->setSourceRGB(( (Float)(1) ),( (Float)(1) ),( (Float)(1) ));
HXLINE( 394)										::Array< ::Dynamic> selectedGylphs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 396)										selectionStart = (selectionStart - group1->startIndex);
HXLINE( 397)										selectionEnd = (selectionEnd - group1->startIndex);
HXLINE( 398)										if ((selectionEnd > glyphs->length)) {
HXLINE( 400)											selectionEnd = glyphs->length;
            										}
HXLINE( 403)										{
HXLINE( 403)											int _g8 = selectionStart;
HXDLIN( 403)											int _g9 = selectionEnd;
HXDLIN( 403)											while((_g8 < _g9)){
HXLINE( 403)												_g8 = (_g8 + 1);
HXDLIN( 403)												int i3 = (_g8 - 1);
HXLINE( 404)												selectedGylphs->push(glyphs->__get(i3).StaticCast<  ::lime::graphics::cairo::CairoGlyph >());
            											}
            										}
HXLINE( 405)										cairo->showGlyphs(selectedGylphs);
            									}
            								}
            							}
            						}
HXLINE( 412)						if (( (bool)(group1->format->underline) )) {
HXLINE( 414)							Float underlineThickness;
HXLINE( 415)							bool _hx_tmp29;
HXDLIN( 415)							if (::hx::IsNotNull( font )) {
HXLINE( 415)								_hx_tmp29 = (font->underlineThickness != ((Float)0.0));
            							}
            							else {
HXLINE( 415)								_hx_tmp29 = false;
            							}
HXDLIN( 415)							if (_hx_tmp29) {
HXLINE( 417)								underlineThickness = ((( (Float)(font->underlineThickness) ) / ( (Float)(font->unitsPerEM) )) * ( (Float)(group1->format->size) ));
            							}
            							else {
HXLINE( 421)								underlineThickness = ::Math_obj::max(((Float)1.0),(((Float)0.05) * ( (Float)(group1->format->size) )));
            							}
HXLINE( 424)							Float underlinePosition;
HXLINE( 425)							bool _hx_tmp30;
HXDLIN( 425)							if (::hx::IsNotNull( font )) {
HXLINE( 425)								_hx_tmp30 = (font->underlinePosition != ((Float)0.0));
            							}
            							else {
HXLINE( 425)								_hx_tmp30 = false;
            							}
HXDLIN( 425)							if (_hx_tmp30) {
HXLINE( 427)								underlinePosition = (-((( (Float)(font->underlinePosition) ) / ( (Float)(font->unitsPerEM) ))) * ( (Float)(group1->format->size) ));
            							}
            							else {
HXLINE( 431)								underlinePosition = (::Math_obj::floor((group1->ascent * ((Float)0.185))) + ((Float)0.5));
            							}
HXLINE( 434)							cairo->newPath();
HXLINE( 435)							cairo->set_lineWidth(underlineThickness);
HXLINE( 436)							Float x1 = ((group1->offsetX + scrollX) - bounds->x);
HXLINE( 437)							Float y1 = ((((group1->offsetY + scrollY) + group1->ascent) - bounds->y) + underlinePosition);
HXLINE( 438)							cairo->moveTo(x1,y1);
HXLINE( 439)							cairo->lineTo((x1 + group1->width),y1);
HXLINE( 440)							cairo->stroke();
HXLINE( 441)							cairo->closePath();
            						}
HXLINE( 444)						if (( (bool)(group1->format->strikethrough) )) {
HXLINE( 447)							Float strikethroughThickness;
HXLINE( 448)							bool _hx_tmp31;
HXDLIN( 448)							if (::hx::IsNotNull( font )) {
HXLINE( 448)								_hx_tmp31 = (font->strikethroughThickness != ((Float)0.0));
            							}
            							else {
HXLINE( 448)								_hx_tmp31 = false;
            							}
HXDLIN( 448)							if (_hx_tmp31) {
HXLINE( 450)								strikethroughThickness = ((( (Float)(font->strikethroughThickness) ) / ( (Float)(font->unitsPerEM) )) * ( (Float)(group1->format->size) ));
            							}
            							else {
HXLINE( 454)								strikethroughThickness = ::Math_obj::max(((Float)1.0),(((Float)0.05) * ( (Float)(group1->format->size) )));
            							}
HXLINE( 456)							Float strikethroughPosition;
HXLINE( 457)							bool _hx_tmp32;
HXDLIN( 457)							if (::hx::IsNotNull( font )) {
HXLINE( 457)								_hx_tmp32 = (font->strikethroughPosition != ((Float)0.0));
            							}
            							else {
HXLINE( 457)								_hx_tmp32 = false;
            							}
HXDLIN( 457)							if (_hx_tmp32) {
HXLINE( 459)								strikethroughPosition = (-((( (Float)(font->strikethroughPosition) ) / ( (Float)(font->unitsPerEM) ))) * ( (Float)(group1->format->size) ));
            							}
            							else {
HXLINE( 463)								strikethroughPosition = (-(group1->ascent) / ((Float)3.0));
            							}
HXLINE( 470)							cairo->newPath();
HXLINE( 471)							cairo->set_lineWidth(strikethroughThickness);
HXLINE( 472)							Float x2 = ((group1->offsetX + scrollX) - bounds->x);
HXLINE( 473)							Float y2 = ((((group1->offsetY + scrollY) + group1->ascent) - bounds->y) + strikethroughPosition);
HXLINE( 474)							cairo->moveTo(x2,y2);
HXLINE( 475)							cairo->lineTo((x2 + group1->width),y2);
HXLINE( 476)							cairo->stroke();
HXLINE( 477)							cairo->closePath();
            						}
            					}
            				}
            				_hx_goto_2:;
            			}
            		}
            		else {
HXLINE( 482)			bool _hx_tmp33;
HXDLIN( 482)			bool _hx_tmp34;
HXDLIN( 482)			if ((textField->_hx___caretIndex > -1)) {
HXLINE( 482)				_hx_tmp34 = textEngine->selectable;
            			}
            			else {
HXLINE( 482)				_hx_tmp34 = false;
            			}
HXDLIN( 482)			if (_hx_tmp34) {
HXLINE( 482)				_hx_tmp33 = textField->_hx___showCursor;
            			}
            			else {
HXLINE( 482)				_hx_tmp33 = false;
            			}
HXDLIN( 482)			if (_hx_tmp33) {
HXLINE( 484)				Float scrollX1;
HXDLIN( 484)				if (useTextBounds1) {
HXLINE( 484)					scrollX1 = ( (Float)(0) );
            				}
            				else {
HXLINE( 484)					scrollX1 = cursorOffsetX;
            				}
HXDLIN( 484)				Float scrollX2 = (-(textField->get_scrollH()) + scrollX1);
HXLINE( 485)				Float scrollY2 = ((Float)0.0);
HXLINE( 487)				{
HXLINE( 487)					int _g10 = 0;
HXDLIN( 487)					int _g11 = (textField->get_scrollV() - 1);
HXDLIN( 487)					while((_g10 < _g11)){
HXLINE( 487)						_g10 = (_g10 + 1);
HXDLIN( 487)						int i4 = (_g10 - 1);
HXLINE( 489)						scrollY2 = (scrollY2 + textEngine->lineHeights->get(i4));
            					}
            				}
HXLINE( 492)				 ::Dynamic color3 = textField->get_defaultTextFormat()->color;
HXLINE( 493)				Float r3 = (( (Float)(::hx::UShr((( (int)(color3) ) & 16711680),16)) ) / ( (Float)(255) ));
HXLINE( 494)				Float g3 = (( (Float)(::hx::UShr((( (int)(color3) ) & 65280),8)) ) / ( (Float)(255) ));
HXLINE( 495)				Float b3 = (( (Float)((( (int)(color3) ) & 255)) ) / ( (Float)(255) ));
HXLINE( 497)				cairo->setSourceRGB(r3,g3,b3);
HXLINE( 499)				cairo->newPath();
HXLINE( 500)				cairo->moveTo((scrollX2 + ((Float)2.5)),(scrollY2 + ((Float)2.5)));
HXLINE( 501)				cairo->set_lineWidth(( (Float)(1) ));
HXLINE( 502)				cairo->lineTo((scrollX2 + ((Float)2.5)),((scrollY2 + ::openfl::text::_internal::TextEngine_obj::getFormatHeight(textField->get_defaultTextFormat())) - ( (Float)(1) )));
HXLINE( 503)				cairo->stroke();
HXLINE( 504)				cairo->closePath();
            			}
            		}
HXLINE( 507)		graphics->_hx___bitmap->image->dirty = true;
HXLINE( 508)		graphics->_hx___bitmap->image->version++;
HXLINE( 509)		textField->_hx___dirty = false;
HXLINE( 510)		graphics->_hx___softwareDirty = false;
HXLINE( 511)		graphics->set___dirty(false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(CairoTextField_obj,render,(void))

void CairoTextField_obj::renderDrawable( ::openfl::text::TextField textField, ::openfl::display::CairoRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_a654946cfcca811d_516_renderDrawable)
HXLINE( 518)		renderer->_hx___updateCacheBitmap(textField,textField->_hx___dirty);
HXLINE( 520)		bool _hx_tmp;
HXDLIN( 520)		if (::hx::IsNotNull( textField->_hx___cacheBitmap )) {
HXLINE( 520)			_hx_tmp = !(textField->_hx___isCacheBitmapRender);
            		}
            		else {
HXLINE( 520)			_hx_tmp = false;
            		}
HXDLIN( 520)		if (_hx_tmp) {
HXLINE( 522)			 ::openfl::display::Bitmap bitmap = textField->_hx___cacheBitmap;
HXDLIN( 522)			if (bitmap->_hx___renderable) {
HXLINE( 522)				Float alpha = renderer->_hx___getAlpha(bitmap->_hx___worldAlpha);
HXDLIN( 522)				bool _hx_tmp1;
HXDLIN( 522)				bool _hx_tmp2;
HXDLIN( 522)				if ((alpha > 0)) {
HXLINE( 522)					_hx_tmp2 = ::hx::IsNotNull( bitmap->_hx___bitmapData );
            				}
            				else {
HXLINE( 522)					_hx_tmp2 = false;
            				}
HXDLIN( 522)				if (_hx_tmp2) {
HXLINE( 522)					_hx_tmp1 = bitmap->_hx___bitmapData->_hx___isValid;
            				}
            				else {
HXLINE( 522)					_hx_tmp1 = false;
            				}
HXDLIN( 522)				if (_hx_tmp1) {
HXLINE( 522)					 ::lime::graphics::cairo::Cairo cairo = renderer->cairo;
HXDLIN( 522)					renderer->_hx___setBlendMode(bitmap->_hx___worldBlendMode);
HXDLIN( 522)					renderer->_hx___pushMaskObject(bitmap,null());
HXDLIN( 522)					renderer->applyMatrix(bitmap->_hx___renderTransform,cairo);
HXDLIN( 522)					 ::Dynamic surface = bitmap->_hx___bitmapData->getSurface();
HXDLIN( 522)					if (::hx::IsNotNull( surface )) {
HXLINE( 522)						 ::Dynamic pattern = ::lime::graphics::cairo::_CairoPattern::CairoPattern_Impl__obj::createForSurface(surface);
HXDLIN( 522)						int _hx_tmp3;
HXDLIN( 522)						bool _hx_tmp4;
HXDLIN( 522)						if (renderer->_hx___allowSmoothing) {
HXLINE( 522)							_hx_tmp4 = bitmap->smoothing;
            						}
            						else {
HXLINE( 522)							_hx_tmp4 = false;
            						}
HXDLIN( 522)						if (_hx_tmp4) {
HXLINE( 522)							_hx_tmp3 = 1;
            						}
            						else {
HXLINE( 522)							_hx_tmp3 = 3;
            						}
HXDLIN( 522)						::lime::graphics::cairo::_CairoPattern::CairoPattern_Impl__obj::set_filter(pattern,_hx_tmp3);
HXDLIN( 522)						cairo->set_source(pattern);
HXDLIN( 522)						if ((alpha == 1)) {
HXLINE( 522)							cairo->paint();
            						}
            						else {
HXLINE( 522)							cairo->paintWithAlpha(alpha);
            						}
            					}
HXDLIN( 522)					renderer->_hx___popMaskObject(bitmap,null());
HXDLIN( 522)					renderer->_hx___setBlendMode(10);
            				}
            			}
            		}
            		else {
HXLINE( 526)			::openfl::display::_internal::CairoTextField_obj::render(textField,renderer,textField->_hx___worldTransform);
HXLINE( 527)			::openfl::display::_internal::CairoDisplayObject_obj::render(textField,renderer);
            		}
HXLINE( 530)		renderer->_hx___renderEvent(textField);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CairoTextField_obj,renderDrawable,(void))

void CairoTextField_obj::renderDrawableMask( ::openfl::text::TextField textField, ::openfl::display::CairoRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_a654946cfcca811d_536_renderDrawableMask)
HXDLIN( 536)		if (::hx::IsNotNull( textField->_hx___graphics )) {
HXDLIN( 536)			::openfl::display::_internal::CairoGraphics_obj::renderMask(textField->_hx___graphics,renderer);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CairoTextField_obj,renderDrawableMask,(void))


CairoTextField_obj::CairoTextField_obj()
{
}

bool CairoTextField_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"renderDrawable") ) { outValue = renderDrawable_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"renderDrawableMask") ) { outValue = renderDrawableMask_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *CairoTextField_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *CairoTextField_obj_sStaticStorageInfo = 0;
#endif

::hx::Class CairoTextField_obj::__mClass;

static ::String CairoTextField_obj_sStaticFields[] = {
	HX_("render",56,6b,29,05),
	HX_("renderDrawable",14,59,d0,dd),
	HX_("renderDrawableMask",20,e0,a3,66),
	::String(null())
};

void CairoTextField_obj::__register()
{
	CairoTextField_obj _hx_dummy;
	CairoTextField_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("openfl.display._internal.CairoTextField",21,a3,1c,94);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CairoTextField_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(CairoTextField_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< CairoTextField_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CairoTextField_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CairoTextField_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void CairoTextField_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_a654946cfcca811d_31_boot)
HXDLIN(  31)		__mClass->__meta__ =  ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("obj",f7,8f,54,00), ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("SuppressWarnings",0c,d3,d2,00),::cpp::VirtualArray_obj::__new(1)->init(0,HX_("checkstyle:FieldDocComment",70,56,1b,20))))));
            	}
}

} // end namespace openfl
} // end namespace display
} // end namespace _internal
