// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math__FlxPoint_FlxPoint_Impl_
#include <flixel/math/_FlxPoint/FlxPoint_Impl_.h>
#endif
#ifndef INCLUDED_flixel_system_debug_Icon
#include <flixel/system/debug/Icon.h>
#endif
#ifndef INCLUDED_flixel_system_debug_Tooltip
#include <flixel/system/debug/Tooltip.h>
#endif
#ifndef INCLUDED_flixel_system_debug_TooltipOverlay
#include <flixel/system/debug/TooltipOverlay.h>
#endif
#ifndef INCLUDED_flixel_system_debug_Window
#include <flixel/system/debug/Window.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_Rotate
#include <flixel/system/debug/_Icon/Rotate.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_ScaleX
#include <flixel/system/debug/_Icon/ScaleX.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_ScaleXY
#include <flixel/system/debug/_Icon/ScaleXY.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_ScaleY
#include <flixel/system/debug/_Icon/ScaleY.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_Transform
#include <flixel/system/debug/_Icon/Transform.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_Interaction
#include <flixel/system/debug/interaction/Interaction.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools_Tool
#include <flixel/system/debug/interaction/tools/Tool.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools_Transform
#include <flixel/system/debug/interaction/tools/Transform.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Transform_Marker
#include <flixel/system/debug/interaction/tools/_Transform/Marker.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Transform_State
#include <flixel/system/debug/interaction/tools/_Transform/State.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Transform_TransformAction
#include <flixel/system/debug/interaction/tools/_Transform/TransformAction.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Transform_TransformTooltip_Impl_
#include <flixel/system/debug/interaction/tools/_Transform/TransformTooltip_Impl_.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal0
#include <flixel/util/_FlxSignal/FlxSignal0.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_32e1ba20177d3a98_25_new,"flixel.system.debug.interaction.tools.Transform","new",0xc0c1ec87,"flixel.system.debug.interaction.tools.Transform.new","flixel/system/debug/interaction/tools/Transform.hx",25,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_51_init,"flixel.system.debug.interaction.tools.Transform","init",0xe5a5c109,"flixel.system.debug.interaction.tools.Transform.init","flixel/system/debug/interaction/tools/Transform.hx",51,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_32_init,"flixel.system.debug.interaction.tools.Transform","init",0xe5a5c109,"flixel.system.debug.interaction.tools.Transform.init","flixel/system/debug/interaction/tools/Transform.hx",32,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_60_activate,"flixel.system.debug.interaction.tools.Transform","activate",0x6c83922c,"flixel.system.debug.interaction.tools.Transform.activate","flixel/system/debug/interaction/tools/Transform.hx",60,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_84_deactivate,"flixel.system.debug.interaction.tools.Transform","deactivate",0xc07e22ed,"flixel.system.debug.interaction.tools.Transform.deactivate","flixel/system/debug/interaction/tools/Transform.hx",84,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_94_startAction,"flixel.system.debug.interaction.tools.Transform","startAction",0xf6ddb4df,"flixel.system.debug.interaction.tools.Transform.startAction","flixel/system/debug/interaction/tools/Transform.hx",94,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_118_checkMarkers,"flixel.system.debug.interaction.tools.Transform","checkMarkers",0x87c3ec8a,"flixel.system.debug.interaction.tools.Transform.checkMarkers","flixel/system/debug/interaction/tools/Transform.hx",118,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_144_update,"flixel.system.debug.interaction.tools.Transform","update",0xdb183c42,"flixel.system.debug.interaction.tools.Transform.update","flixel/system/debug/interaction/tools/Transform.hx",144,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_163_update,"flixel.system.debug.interaction.tools.Transform","update",0xdb183c42,"flixel.system.debug.interaction.tools.Transform.update","flixel/system/debug/interaction/tools/Transform.hx",163,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_222_draw,"flixel.system.debug.interaction.tools.Transform","draw",0xe25ab1fd,"flixel.system.debug.interaction.tools.Transform.draw","flixel/system/debug/interaction/tools/Transform.hx",222,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_32e1ba20177d3a98_249_drawSelection,"flixel.system.debug.interaction.tools.Transform","drawSelection",0xb8cd7e8f,"flixel.system.debug.interaction.tools.Transform.drawSelection","flixel/system/debug/interaction/tools/Transform.hx",249,0xb006466c)
namespace flixel{
namespace _hx_system{
namespace debug{
namespace interaction{
namespace tools{

void Transform_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_25_new)
HXLINE(  29)		this->markers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  28)		 ::flixel::_hx_system::debug::TooltipOverlay this1 = ::flixel::_hx_system::debug::Tooltip_obj::add(null(),HX_("",00,00,00,00));
HXDLIN(  28)		this1->textField->set_wordWrap(false);
HXDLIN(  28)		this1->set_visible(false);
HXDLIN(  28)		this->tooltip = this1;
HXLINE(  27)		this->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::IDLE_dyn();
HXLINE(  25)		super::__construct();
            	}

Dynamic Transform_obj::__CreateEmpty() { return new Transform_obj; }

void *Transform_obj::_hx_vtable = 0;

Dynamic Transform_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Transform_obj > _hx_result = new Transform_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Transform_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1f4df417) {
		if (inClassId<=(int)0x0c89e854) {
			if (inClassId<=(int)0x0330636f) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
			} else {
				return inClassId==(int)0x0c89e854;
			}
		} else {
			return inClassId==(int)0x1361d5a9 || inClassId==(int)0x1f4df417;
		}
	} else {
		if (inClassId<=(int)0x5020ad7b) {
			return inClassId==(int)0x4af7dd8e || inClassId==(int)0x5020ad7b;
		} else {
			return inClassId==(int)0x6b353933;
		}
	}
}

 ::flixel::_hx_system::debug::interaction::tools::Tool Transform_obj::init( ::flixel::_hx_system::debug::interaction::Interaction brain){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::flixel::_hx_system::debug::interaction::tools::Transform,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_32e1ba20177d3a98_51_init)
HXLINE(  52)			_gthis->tooltip->setVisible(false);
HXLINE(  53)			_gthis->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::IDLE_dyn();
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_32e1ba20177d3a98_32_init)
HXDLIN(  32)		 ::flixel::_hx_system::debug::interaction::tools::Transform _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  33)		this->markers->resize(0);
HXLINE(  34)		::Array< ::Dynamic> _hx_tmp = this->markers;
HXDLIN(  34)		_hx_tmp->push( ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::__alloc( HX_CTX ,HX_("transformRotate",e7,c0,75,06),true,true));
HXLINE(  35)		::Array< ::Dynamic> _hx_tmp1 = this->markers;
HXDLIN(  35)		_hx_tmp1->push( ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::__alloc( HX_CTX ,HX_("transformScaleX",1a,65,7b,77),false,true));
HXLINE(  36)		::Array< ::Dynamic> _hx_tmp2 = this->markers;
HXDLIN(  36)		_hx_tmp2->push( ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::__alloc( HX_CTX ,HX_("transformScaleXY",ff,11,7d,14),false,false));
HXLINE(  37)		::Array< ::Dynamic> _hx_tmp3 = this->markers;
HXDLIN(  37)		_hx_tmp3->push( ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::__alloc( HX_CTX ,HX_("transformScaleY",1b,65,7b,77),true,false));
HXLINE(  39)		this->super::init(brain);
HXLINE(  41)		this->_name = HX_("Transform",4c,0d,66,e7);
HXLINE(  42)		this->setButton(::flixel::_hx_system::debug::Icon_obj::transform);
HXLINE(  43)		this->setCursor(::flixel::_hx_system::debug::Icon_obj::transform,null(),null());
HXLINE(  45)		brain->registerCustomCursor(HX_("transformRotate",e7,c0,75,06),::flixel::_hx_system::debug::Icon_obj::rotate,-5,-5);
HXLINE(  46)		brain->registerCustomCursor(HX_("transformScaleX",1a,65,7b,77),::flixel::_hx_system::debug::Icon_obj::scaleX,-5,-5);
HXLINE(  47)		brain->registerCustomCursor(HX_("transformScaleY",1b,65,7b,77),::flixel::_hx_system::debug::Icon_obj::scaleY,-5,-5);
HXLINE(  48)		brain->registerCustomCursor(HX_("transformScaleXY",ff,11,7d,14),::flixel::_hx_system::debug::Icon_obj::scaleXY,-5,-5);
HXLINE(  50)		::flixel::FlxG_obj::signals->preStateSwitch->add( ::Dynamic(new _hx_Closure_0(_gthis)));
HXLINE(  56)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


void Transform_obj::activate(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_60_activate)
HXLINE(  61)		if ((this->_brain->selectedItems->length == 0)) {
HXLINE(  62)			return;
            		}
HXLINE(  64)		{
HXLINE(  64)			 ::Dynamic filter = null();
HXDLIN(  64)			::Array< ::Dynamic> _g__groupMembers = this->_brain->selectedItems->members;
HXDLIN(  64)			 ::Dynamic _g__filter = filter;
HXDLIN(  64)			int _g__cursor = 0;
HXDLIN(  64)			int _g__length = _g__groupMembers->length;
HXDLIN(  64)			while(true){
HXLINE(  64)				while(true){
HXLINE(  64)					bool _hx_tmp;
HXDLIN(  64)					if ((_g__cursor < _g__length)) {
HXLINE(  64)						if (::hx::IsNotNull( _g__groupMembers->__get(_g__cursor).StaticCast<  ::flixel::FlxObject >() )) {
HXLINE(  64)							if (::hx::IsNotNull( _g__filter )) {
HXLINE(  64)								_hx_tmp = !(( (bool)(_g__filter(_g__groupMembers->__get(_g__cursor).StaticCast<  ::flixel::FlxObject >())) ));
            							}
            							else {
HXLINE(  64)								_hx_tmp = false;
            							}
            						}
            						else {
HXLINE(  64)							_hx_tmp = true;
            						}
            					}
            					else {
HXLINE(  64)						_hx_tmp = false;
            					}
HXDLIN(  64)					if (!(_hx_tmp)) {
HXLINE(  64)						goto _hx_goto_4;
            					}
HXDLIN(  64)					_g__cursor = (_g__cursor + 1);
            				}
            				_hx_goto_4:;
HXDLIN(  64)				if (!((_g__cursor < _g__length))) {
HXLINE(  64)					goto _hx_goto_3;
            				}
HXDLIN(  64)				 ::flixel::FlxObject member;
HXDLIN(  64)				while(true){
HXLINE(  64)					bool member1;
HXDLIN(  64)					if ((_g__cursor < _g__length)) {
HXLINE(  64)						if (::hx::IsNotNull( _g__groupMembers->__get(_g__cursor).StaticCast<  ::flixel::FlxObject >() )) {
HXLINE(  64)							if (::hx::IsNotNull( _g__filter )) {
HXLINE(  64)								member1 = !(( (bool)(_g__filter(_g__groupMembers->__get(_g__cursor).StaticCast<  ::flixel::FlxObject >())) ));
            							}
            							else {
HXLINE(  64)								member1 = false;
            							}
            						}
            						else {
HXLINE(  64)							member1 = true;
            						}
            					}
            					else {
HXLINE(  64)						member1 = false;
            					}
HXDLIN(  64)					if (!(member1)) {
HXLINE(  64)						goto _hx_goto_5;
            					}
HXDLIN(  64)					_g__cursor = (_g__cursor + 1);
            				}
            				_hx_goto_5:;
HXDLIN(  64)				if ((_g__cursor < _g__length)) {
HXLINE(  64)					_g__cursor = (_g__cursor + 1);
HXDLIN(  64)					member = _g__groupMembers->__get((_g__cursor - 1)).StaticCast<  ::flixel::FlxObject >();
            				}
            				else {
HXLINE(  64)					member = null();
            				}
HXDLIN(  64)				 ::flixel::FlxObject member2 = member;
HXLINE(  66)				bool _hx_tmp1;
HXDLIN(  66)				bool _hx_tmp2;
HXDLIN(  66)				if (::hx::IsNotNull( member2 )) {
HXLINE(  66)					_hx_tmp2 = ::hx::IsNotNull( member2->scrollFactor );
            				}
            				else {
HXLINE(  66)					_hx_tmp2 = false;
            				}
HXDLIN(  66)				if (_hx_tmp2) {
HXLINE(  66)					_hx_tmp1 = member2->isOnScreen(null());
            				}
            				else {
HXLINE(  66)					_hx_tmp1 = false;
            				}
HXDLIN(  66)				if (_hx_tmp1) {
HXLINE(  70)					 ::flixel::FlxSprite target = ( ( ::flixel::FlxSprite)(member2) );
HXLINE(  71)					this->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::SELECTED(target);
HXLINE(  73)					{
HXLINE(  73)						int _g = 0;
HXDLIN(  73)						::Array< ::Dynamic> _g1 = this->markers;
HXDLIN(  73)						while((_g < _g1->length)){
HXLINE(  73)							 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker marker = _g1->__get(_g).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >();
HXDLIN(  73)							_g = (_g + 1);
HXLINE(  74)							marker->reposition(target);
            						}
            					}
HXLINE(  76)					goto _hx_goto_3;
            				}
            			}
            			_hx_goto_3:;
            		}
HXLINE(  80)		this->_brain->shouldDrawItemsSelection = false;
            	}


void Transform_obj::deactivate(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_84_deactivate)
HXLINE(  85)		this->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::IDLE_dyn();
HXLINE(  86)		this->_brain->shouldDrawItemsSelection = true;
            	}


void Transform_obj::startAction(::String type){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_94_startAction)
HXLINE(  95)		 ::flixel::FlxSprite target;
HXDLIN(  95)		 ::flixel::_hx_system::debug::interaction::tools::_Transform::State _g = this->state;
HXDLIN(  95)		if ((_g->_hx_getIndex() == 1)) {
HXLINE(  97)			 ::flixel::FlxSprite target1 = _g->_hx_getObject(0).StaticCast<  ::flixel::FlxSprite >();
HXLINE(  95)			target = target1;
            		}
            		else {
HXLINE(  98)			 ::flixel::_hx_system::debug::interaction::tools::_Transform::State found = _g;
HXDLIN(  98)			HX_STACK_DO_THROW((HX_("Unexpected state: ",c8,45,da,ee) + ::Std_obj::string(found)));
            		}
HXLINE( 101)		 ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction action;
HXDLIN( 101)		::String _hx_switch_0 = type;
            		if (  (_hx_switch_0==HX_("transformRotate",e7,c0,75,06)) ){
HXLINE( 101)			action = ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction_obj::SET_ANGLE(target->angle);
HXDLIN( 101)			goto _hx_goto_9;
            		}
            		if (  (_hx_switch_0==HX_("transformScaleX",1a,65,7b,77)) ){
HXLINE( 101)			action = ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction_obj::SET_SCALE_X(target->scale->x);
HXDLIN( 101)			goto _hx_goto_9;
            		}
            		if (  (_hx_switch_0==HX_("transformScaleXY",ff,11,7d,14)) ){
HXLINE( 101)			action = ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction_obj::SET_SCALE_XY(target->scale->x,target->scale->y);
HXDLIN( 101)			goto _hx_goto_9;
            		}
            		if (  (_hx_switch_0==HX_("transformScaleY",1b,65,7b,77)) ){
HXLINE( 101)			action = ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction_obj::SET_SCALE_Y(target->scale->y);
HXDLIN( 101)			goto _hx_goto_9;
            		}
            		_hx_goto_9:;
HXLINE( 109)		this->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::TRANSFORM(target,action,this->_brain->flixelPointer->x,this->_brain->flixelPointer->y);
HXLINE( 111)		 ::flixel::FlxCamera camera = target->getDefaultCamera();
HXLINE( 112)		this->set_x(this->_brain->toDebugX((target->x + target->origin->x),camera));
HXLINE( 113)		this->set_y(this->_brain->toDebugY((target->y + target->origin->y),camera));
HXLINE( 114)		 ::flixel::_hx_system::debug::TooltipOverlay _hx_tmp = this->tooltip;
HXDLIN( 114)		Float _hx_tmp1 = this->get_x();
HXDLIN( 114)		::flixel::_hx_system::debug::interaction::tools::_Transform::TransformTooltip_Impl__obj::show(_hx_tmp,_hx_tmp1,this->get_y());
            	}


HX_DEFINE_DYNAMIC_FUNC1(Transform_obj,startAction,(void))

void Transform_obj::checkMarkers(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_118_checkMarkers)
HXLINE( 119)		 ::flixel::math::FlxBasePoint mouse = this->_brain->flixelPointer;
HXLINE( 121)		 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker closest = null();
HXLINE( 122)		int closestDist = 10;
HXLINE( 123)		{
HXLINE( 123)			int _g = 0;
HXDLIN( 123)			::Array< ::Dynamic> _g1 = this->markers;
HXDLIN( 123)			while((_g < _g1->length)){
HXLINE( 123)				 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker marker = _g1->__get(_g).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >();
HXDLIN( 123)				_g = (_g + 1);
HXLINE( 125)				Float x = marker->x;
HXDLIN( 125)				Float y = marker->y;
HXDLIN( 125)				Float dist = ::Math_obj::sqrt((((mouse->x - x) * (mouse->x - x)) + ((mouse->y - y) * (mouse->y - y))));
HXLINE( 126)				if ((closestDist > dist)) {
HXLINE( 129)					closest = marker;
            				}
            			}
            		}
HXLINE( 133)		if (::hx::IsNotNull( closest )) {
HXLINE( 135)			this->setCursorInUse(closest->type);
HXLINE( 136)			if (this->_brain->pointerJustPressed) {
HXLINE( 137)				this->startAction(closest->type);
            			}
            		}
            		else {
HXLINE( 140)			this->useDefaultCursor();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Transform_obj,checkMarkers,(void))

void Transform_obj::update(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_144_update)
HXLINE( 145)		if (!(this->isActive())) {
HXLINE( 146)			return;
            		}
HXLINE( 148)		{
HXLINE( 148)			 ::flixel::_hx_system::debug::interaction::tools::_Transform::State _g = this->state;
HXDLIN( 148)			switch((int)(_g->_hx_getIndex())){
            				case (int)0: {
            				}
            				break;
            				case (int)1: {
HXLINE( 151)					 ::flixel::FlxSprite target = _g->_hx_getObject(0).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 152)					this->checkMarkers();
            				}
            				break;
            				case (int)2: {
HXLINE( 153)					 ::flixel::FlxSprite target1 = _g->_hx_getObject(0).StaticCast<  ::flixel::FlxSprite >();
HXDLIN( 153)					 ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction type = _g->_hx_getObject(1).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction >();
HXDLIN( 153)					Float mouseStartX = _g->_hx_getFloat(2);
HXDLIN( 153)					Float mouseStartY = _g->_hx_getFloat(3);
HXDLIN( 153)					{
            						HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            						::String _hx_run(Float num, ::Dynamic __o_dec){
            		int dec = __o_dec.Default(2);
            							HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_163_update)
HXLINE( 164)							::String prefix;
HXDLIN( 164)							if ((num > 0)) {
HXLINE( 164)								prefix = HX_("",00,00,00,00);
            							}
            							else {
HXLINE( 164)								prefix = HX_("-",2d,00,00,00);
            							}
HXDLIN( 164)							::String prefix1;
HXDLIN( 164)							if ((num < ((Float)1.0))) {
HXLINE( 164)								prefix1 = HX_("0",30,00,00,00);
            							}
            							else {
HXLINE( 164)								prefix1 = HX_("",00,00,00,00);
            							}
HXDLIN( 164)							::String prefix2 = (prefix + prefix1);
HXLINE( 165)							Float num1;
HXDLIN( 165)							if ((num < 0)) {
HXLINE( 165)								num1 = -(num);
            							}
            							else {
HXLINE( 165)								num1 = num;
            							}
HXDLIN( 165)							::String digits = ::Std_obj::string(::Std_obj::_hx_int((num1 * ::Math_obj::pow(( (Float)(10) ),( (Float)(dec) )))));
HXLINE( 166)							::String dec1 = ((prefix2 + digits.substr(0,-(dec))) + HX_(".",2e,00,00,00));
HXDLIN( 166)							return (dec1 + digits.substr(-(dec),dec));
            						}
            						HX_END_LOCAL_FUNC2(return)

HXLINE( 154)						 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(mouseStartX,mouseStartY);
HXDLIN( 154)						point->_inPool = false;
HXDLIN( 154)						 ::flixel::math::FlxBasePoint this1 = point;
HXDLIN( 154)						 ::flixel::math::FlxBasePoint mouseStart = this1->set((this1->x - (target1->x + target1->origin->x)),(this1->y - (target1->y + target1->origin->y)));
HXLINE( 156)						 ::flixel::math::FlxBasePoint this2 = this->_brain->flixelPointer;
HXDLIN( 156)						 ::flixel::math::FlxBasePoint p = null();
HXDLIN( 156)						if (::hx::IsNull( p )) {
HXLINE( 156)							 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 156)							point1->_inPool = false;
HXDLIN( 156)							p = point1;
            						}
HXDLIN( 156)						 ::flixel::math::FlxBasePoint this3 = p->set(this2->x,this2->y);
HXDLIN( 156)						 ::flixel::math::FlxBasePoint mouse = this3->set((this3->x - (target1->x + target1->origin->x)),(this3->y - (target1->y + target1->origin->y)));
HXLINE( 162)						 ::Dynamic dec =  ::Dynamic(new _hx_Closure_0());
HXLINE( 169)						switch((int)(type->_hx_getIndex())){
            							case (int)0: {
HXLINE( 171)								Float startValue = type->_hx_getFloat(0);
HXDLIN( 171)								{
HXLINE( 172)									Float _hx_tmp = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouse);
HXDLIN( 172)									Float _hx_tmp1 = (_hx_tmp * (( (Float)(180) ) / ::Math_obj::PI));
HXDLIN( 172)									Float _hx_tmp2 = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouseStart);
HXDLIN( 172)									target1->set_angle(((_hx_tmp1 - (_hx_tmp2 * (( (Float)(180) ) / ::Math_obj::PI))) + startValue));
HXLINE( 174)									 ::flixel::_hx_system::debug::TooltipOverlay _hx_tmp3 = this->tooltip;
HXDLIN( 174)									::String _hx_tmp4 = ((HX_("deg: ",ec,e9,22,d7) + dec(target1->angle,1)) + HX_("\n rad: ",25,17,5a,4f));
HXDLIN( 174)									_hx_tmp3->setText((_hx_tmp4 + dec((target1->angle * (::Math_obj::PI / ( (Float)(180) ))),2)));
            								}
            							}
            							break;
            							case (int)1: {
HXLINE( 176)								Float startValue1 = type->_hx_getFloat(0);
HXDLIN( 176)								{
HXLINE( 177)									Float oldProjX = ::Math_obj::sqrt(((mouseStart->x * mouseStart->x) + (mouseStart->y * mouseStart->y)));
HXDLIN( 177)									Float target2 = target1->angle;
HXDLIN( 177)									Float degrees = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouseStart);
HXDLIN( 177)									Float oldProjX1 = (oldProjX * ::Math_obj::cos(((::Math_obj::PI / ( (Float)(180) )) * (target2 - (degrees * (( (Float)(180) ) / ::Math_obj::PI))))));
HXLINE( 178)									Float projX = ::Math_obj::sqrt(((mouse->x * mouse->x) + (mouse->y * mouse->y)));
HXDLIN( 178)									Float target3 = target1->angle;
HXDLIN( 178)									Float degrees1 = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouse);
HXDLIN( 178)									Float projX1 = (projX * ::Math_obj::cos(((::Math_obj::PI / ( (Float)(180) )) * (target3 - (degrees1 * (( (Float)(180) ) / ::Math_obj::PI))))));
HXLINE( 180)									target1->scale->set_x(((projX1 / oldProjX1) * startValue1));
HXLINE( 182)									 ::flixel::_hx_system::debug::TooltipOverlay _hx_tmp5 = this->tooltip;
HXDLIN( 182)									::String _hx_tmp6 = ((HX_("scale.x: ",3a,ed,5c,17) + dec(target1->scale->x,null())) + HX_("\n height: ",23,11,61,14));
HXDLIN( 182)									_hx_tmp5->setText((_hx_tmp6 + ::Std_obj::_hx_int((target1->scale->x * ( (Float)(target1->frameWidth) )))));
            								}
            							}
            							break;
            							case (int)2: {
HXLINE( 184)								Float startValue2 = type->_hx_getFloat(0);
HXDLIN( 184)								{
HXLINE( 185)									Float oldProjY = ::Math_obj::sqrt(((mouseStart->x * mouseStart->x) + (mouseStart->y * mouseStart->y)));
HXDLIN( 185)									Float target4 = target1->angle;
HXDLIN( 185)									Float degrees2 = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouseStart);
HXDLIN( 185)									Float oldProjY1 = (oldProjY * ::Math_obj::sin(((::Math_obj::PI / ( (Float)(180) )) * (target4 - (degrees2 * (( (Float)(180) ) / ::Math_obj::PI))))));
HXLINE( 186)									Float projY = ::Math_obj::sqrt(((mouse->x * mouse->x) + (mouse->y * mouse->y)));
HXDLIN( 186)									Float target5 = target1->angle;
HXDLIN( 186)									Float degrees3 = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouse);
HXDLIN( 186)									Float projY1 = (projY * ::Math_obj::sin(((::Math_obj::PI / ( (Float)(180) )) * (target5 - (degrees3 * (( (Float)(180) ) / ::Math_obj::PI))))));
HXLINE( 187)									target1->scale->set_y(((projY1 / oldProjY1) * startValue2));
HXLINE( 189)									 ::flixel::_hx_system::debug::TooltipOverlay _hx_tmp7 = this->tooltip;
HXDLIN( 189)									::String _hx_tmp8 = ((HX_("scale.y: ",7b,af,5d,17) + dec(target1->scale->y,null())) + HX_("\n height: ",23,11,61,14));
HXDLIN( 189)									_hx_tmp7->setText((_hx_tmp8 + ::Std_obj::_hx_int((target1->scale->y * ( (Float)(target1->frameHeight) )))));
            								}
            							}
            							break;
            							case (int)3: {
HXLINE( 191)								Float startValueX = type->_hx_getFloat(0);
HXDLIN( 191)								Float startValueY = type->_hx_getFloat(1);
HXDLIN( 191)								{
HXLINE( 192)									Float oldLen = ::Math_obj::sqrt(((mouseStart->x * mouseStart->x) + (mouseStart->y * mouseStart->y)));
HXLINE( 193)									Float oldDeg = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouseStart);
HXDLIN( 193)									Float oldDeg1 = (oldDeg * (( (Float)(180) ) / ::Math_obj::PI));
HXLINE( 194)									Float oldProjX2 = (oldLen * ::Math_obj::cos(((::Math_obj::PI / ( (Float)(180) )) * (target1->angle - oldDeg1))));
HXLINE( 195)									Float oldProjY2 = (oldLen * ::Math_obj::sin(((::Math_obj::PI / ( (Float)(180) )) * (target1->angle - oldDeg1))));
HXLINE( 196)									Float len = ::Math_obj::sqrt(((mouse->x * mouse->x) + (mouse->y * mouse->y)));
HXLINE( 197)									Float deg = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(mouse);
HXDLIN( 197)									Float deg1 = (deg * (( (Float)(180) ) / ::Math_obj::PI));
HXLINE( 198)									Float projX2 = (len * ::Math_obj::cos(((::Math_obj::PI / ( (Float)(180) )) * (target1->angle - deg1))));
HXLINE( 199)									Float projY2 = (len * ::Math_obj::sin(((::Math_obj::PI / ( (Float)(180) )) * (target1->angle - deg1))));
HXLINE( 201)									target1->scale->set_x(((projX2 / oldProjX2) * startValueX));
HXLINE( 202)									target1->scale->set_y(((projY2 / oldProjY2) * startValueY));
HXLINE( 203)									::String info = ((HX_("scale - { x: ",30,87,3a,18) + dec(target1->scale->x,null())) + HX_(" | y: ",9b,51,9e,46));
HXDLIN( 203)									::String info1 = ((info + dec(target1->scale->y,2)) + HX_(" }\n",0d,b5,18,00));
HXLINE( 204)									::String info2 = ((HX_("size   - { x: ",a7,b6,11,cd) + ::Std_obj::_hx_int((target1->scale->x * ( (Float)(target1->frameWidth) )))) + HX_(" | y: ",9b,51,9e,46));
HXLINE( 203)									::String info3 = (info1 + ((info2 + ::Std_obj::_hx_int((target1->scale->y * ( (Float)(target1->frameHeight) )))) + HX_(" }",5d,1c,00,00)));
HXLINE( 205)									this->tooltip->setText(info3);
            								}
            							}
            							break;
            						}
HXLINE( 207)						mouseStart->put();
HXLINE( 208)						mouse->put();
HXLINE( 210)						{
HXLINE( 210)							int _g1 = 0;
HXDLIN( 210)							::Array< ::Dynamic> _g2 = this->markers;
HXDLIN( 210)							while((_g1 < _g2->length)){
HXLINE( 210)								 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker marker = _g2->__get(_g1).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >();
HXDLIN( 210)								_g1 = (_g1 + 1);
HXLINE( 211)								marker->reposition(target1);
            							}
            						}
HXLINE( 213)						if (this->_brain->pointerJustReleased) {
HXLINE( 215)							this->state = ::flixel::_hx_system::debug::interaction::tools::_Transform::State_obj::SELECTED(target1);
HXLINE( 216)							this->tooltip->setVisible(false);
            						}
            					}
            				}
            				break;
            			}
            		}
            	}


void Transform_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_222_draw)
HXLINE( 223)		if (!(this->isActive())) {
HXLINE( 224)			return;
            		}
HXLINE( 226)		 ::flixel::FlxSprite target;
HXDLIN( 226)		 ::flixel::_hx_system::debug::interaction::tools::_Transform::State _g = this->state;
HXDLIN( 226)		switch((int)(_g->_hx_getIndex())){
            			case (int)0: {
HXLINE( 229)				return;
            			}
            			break;
            			case (int)1: {
HXLINE( 230)				 ::flixel::FlxSprite target1 = _g->_hx_getObject(0).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 226)				target = target1;
            			}
            			break;
            			case (int)2: {
HXLINE( 232)				 ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction _g1 = _g->_hx_getObject(1).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::TransformAction >();
HXDLIN( 232)				Float _g2 = _g->_hx_getFloat(2);
HXDLIN( 232)				Float _g3 = _g->_hx_getFloat(3);
HXDLIN( 232)				 ::flixel::FlxSprite target2 = _g->_hx_getObject(0).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 226)				target = target2;
            			}
            			break;
            		}
HXLINE( 236)		 ::openfl::display::Graphics gfx = this->_brain->getDebugGraphics();
HXLINE( 237)		if (::hx::IsNull( gfx )) {
HXLINE( 238)			return;
            		}
HXLINE( 240)		this->drawSelection(gfx,target->getDefaultCamera());
HXLINE( 241)		::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::draw((target->x + target->origin->x),(target->y + target->origin->y),false,gfx);
HXLINE( 244)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 245)			::flixel::FlxG_obj::camera->buffer->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


void Transform_obj::drawSelection( ::openfl::display::Graphics gfx, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_32e1ba20177d3a98_249_drawSelection)
HXLINE( 250)		gfx->lineStyle(((Float)1.0),-65281,((Float)1.0),false,2,2,null(),null());
HXLINE( 253)		gfx->moveTo(this->markers->__get(3).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >()->x,this->markers->__get(3).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >()->y);
HXLINE( 254)		{
HXLINE( 254)			int _g = 0;
HXDLIN( 254)			::Array< ::Dynamic> _g1 = this->markers;
HXDLIN( 254)			while((_g < _g1->length)){
HXLINE( 254)				 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker marker = _g1->__get(_g).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >();
HXDLIN( 254)				_g = (_g + 1);
HXLINE( 255)				gfx->lineTo(marker->x,marker->y);
            			}
            		}
HXLINE( 258)		{
HXLINE( 258)			int _g2 = 0;
HXDLIN( 258)			::Array< ::Dynamic> _g3 = this->markers;
HXDLIN( 258)			while((_g2 < _g3->length)){
HXLINE( 258)				 ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker marker1 = _g3->__get(_g2).StaticCast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::Marker >();
HXDLIN( 258)				_g2 = (_g2 + 1);
HXLINE( 260)				Float x = marker1->x;
HXLINE( 261)				Float y = marker1->y;
HXLINE( 262)				::flixel::_hx_system::debug::interaction::tools::_Transform::Marker_obj::draw(x,y,(marker1->type == HX_("transformRotate",e7,c0,75,06)),gfx);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Transform_obj,drawSelection,(void))


::hx::ObjectPtr< Transform_obj > Transform_obj::__new() {
	::hx::ObjectPtr< Transform_obj > __this = new Transform_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Transform_obj > Transform_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Transform_obj *__this = (Transform_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Transform_obj), true, "flixel.system.debug.interaction.tools.Transform"));
	*(void **)__this = Transform_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Transform_obj::Transform_obj()
{
}

void Transform_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Transform);
	HX_MARK_MEMBER_NAME(state,"state");
	HX_MARK_MEMBER_NAME(tooltip,"tooltip");
	HX_MARK_MEMBER_NAME(markers,"markers");
	 ::flixel::_hx_system::debug::interaction::tools::Tool_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Transform_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(state,"state");
	HX_VISIT_MEMBER_NAME(tooltip,"tooltip");
	HX_VISIT_MEMBER_NAME(markers,"markers");
	 ::flixel::_hx_system::debug::interaction::tools::Tool_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Transform_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { return ::hx::Val( init_dyn() ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { return ::hx::Val( state ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tooltip") ) { return ::hx::Val( tooltip ); }
		if (HX_FIELD_EQ(inName,"markers") ) { return ::hx::Val( markers ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"activate") ) { return ::hx::Val( activate_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"deactivate") ) { return ::hx::Val( deactivate_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"startAction") ) { return ::hx::Val( startAction_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"checkMarkers") ) { return ::hx::Val( checkMarkers_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"drawSelection") ) { return ::hx::Val( drawSelection_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Transform_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { state=inValue.Cast<  ::flixel::_hx_system::debug::interaction::tools::_Transform::State >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tooltip") ) { tooltip=inValue.Cast<  ::flixel::_hx_system::debug::TooltipOverlay >(); return inValue; }
		if (HX_FIELD_EQ(inName,"markers") ) { markers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Transform_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("state",11,76,0b,84));
	outFields->push(HX_("tooltip",03,ad,8c,6a));
	outFields->push(HX_("markers",79,8d,f6,67));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Transform_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::_hx_system::debug::interaction::tools::_Transform::State */ ,(int)offsetof(Transform_obj,state),HX_("state",11,76,0b,84)},
	{::hx::fsObject /*  ::flixel::_hx_system::debug::TooltipOverlay */ ,(int)offsetof(Transform_obj,tooltip),HX_("tooltip",03,ad,8c,6a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Transform_obj,markers),HX_("markers",79,8d,f6,67)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Transform_obj_sStaticStorageInfo = 0;
#endif

static ::String Transform_obj_sMemberFields[] = {
	HX_("state",11,76,0b,84),
	HX_("tooltip",03,ad,8c,6a),
	HX_("markers",79,8d,f6,67),
	HX_("init",10,3b,bb,45),
	HX_("activate",b3,1b,ac,e5),
	HX_("deactivate",34,5c,01,3c),
	HX_("startAction",b8,99,2c,8e),
	HX_("checkMarkers",91,45,7d,55),
	HX_("update",09,86,05,87),
	HX_("draw",04,2c,70,42),
	HX_("drawSelection",a8,0b,42,ed),
	::String(null()) };

::hx::Class Transform_obj::__mClass;

void Transform_obj::__register()
{
	Transform_obj _hx_dummy;
	Transform_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.system.debug.interaction.tools.Transform",15,9d,09,e9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Transform_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Transform_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Transform_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Transform_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace system
} // end namespace debug
} // end namespace interaction
} // end namespace tools
