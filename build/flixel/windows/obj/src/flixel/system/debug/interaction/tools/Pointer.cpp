// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedContainer
#include <flixel/group/FlxTypedContainer.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_debug_Icon
#include <flixel/system/debug/Icon.h>
#endif
#ifndef INCLUDED_flixel_system_debug_Window
#include <flixel/system/debug/Window.h>
#endif
#ifndef INCLUDED_flixel_system_debug__Icon_Cross
#include <flixel/system/debug/_Icon/Cross.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_Interaction
#include <flixel/system/debug/interaction/Interaction.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools_Pointer
#include <flixel/system/debug/interaction/tools/Pointer.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools_Tool
#include <flixel/system/debug/interaction/tools/Tool.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Pointer_Selection
#include <flixel/system/debug/interaction/tools/_Pointer/Selection.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Pointer_State
#include <flixel/system/debug/interaction/tools/_Pointer/State.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_20_new,"flixel.system.debug.interaction.tools.Pointer","new",0x18297018,"flixel.system.debug.interaction.tools.Pointer.new","flixel/system/debug/interaction/tools/Pointer.hx",20,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_25_init,"flixel.system.debug.interaction.tools.Pointer","init",0x08d15c58,"flixel.system.debug.interaction.tools.Pointer.init","flixel/system/debug/interaction/tools/Pointer.hx",25,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_36_update,"flixel.system.debug.interaction.tools.Pointer","update",0xd4dc8951,"flixel.system.debug.interaction.tools.Pointer.update","flixel/system/debug/interaction/tools/Pointer.hx",36,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_76_updateSelected,"flixel.system.debug.interaction.tools.Pointer","updateSelected",0x8b8ea8cc,"flixel.system.debug.interaction.tools.Pointer.updateSelected","flixel/system/debug/interaction/tools/Pointer.hx",76,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_131_cancelSelection,"flixel.system.debug.interaction.tools.Pointer","cancelSelection",0xa173bf2a,"flixel.system.debug.interaction.tools.Pointer.cancelSelection","flixel/system/debug/interaction/tools/Pointer.hx",131,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_135_draw,"flixel.system.debug.interaction.tools.Pointer","draw",0x05864d4c,"flixel.system.debug.interaction.tools.Pointer.draw","flixel/system/debug/interaction/tools/Pointer.hx",135,0x6c93613b)
HX_LOCAL_STACK_FRAME(_hx_pos_dbe290ee08dc8b7a_158_setAbsRect,"flixel.system.debug.interaction.tools.Pointer","setAbsRect",0xdefdf67c,"flixel.system.debug.interaction.tools.Pointer.setAbsRect","flixel/system/debug/interaction/tools/Pointer.hx",158,0x6c93613b)
namespace flixel{
namespace _hx_system{
namespace debug{
namespace interaction{
namespace tools{

void Pointer_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_20_new)
HXLINE(  22)		this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::IDLE_dyn();
HXLINE(  20)		super::__construct();
            	}

Dynamic Pointer_obj::__CreateEmpty() { return new Pointer_obj; }

void *Pointer_obj::_hx_vtable = 0;

Dynamic Pointer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Pointer_obj > _hx_result = new Pointer_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Pointer_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1361d5a9) {
		if (inClassId<=(int)0x092403d4) {
			if (inClassId<=(int)0x0330636f) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
			} else {
				return inClassId==(int)0x092403d4;
			}
		} else {
			return inClassId==(int)0x0c89e854 || inClassId==(int)0x1361d5a9;
		}
	} else {
		if (inClassId<=(int)0x4af7dd8e) {
			return inClassId==(int)0x1f4df417 || inClassId==(int)0x4af7dd8e;
		} else {
			return inClassId==(int)0x6b353933;
		}
	}
}

 ::flixel::_hx_system::debug::interaction::tools::Tool Pointer_obj::init( ::flixel::_hx_system::debug::interaction::Interaction brain){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_25_init)
HXLINE(  26)		this->super::init(brain);
HXLINE(  28)		this->_name = HX_("Pointer",9d,e8,72,1e);
HXLINE(  29)		this->setButton(::flixel::_hx_system::debug::Icon_obj::cross);
HXLINE(  30)		this->setCursor(::flixel::_hx_system::debug::Icon_obj::cross,-5,-5);
HXLINE(  32)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


void Pointer_obj::update(){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_36_update)
HXLINE(  38)		if (!(this->isActive())) {
HXLINE(  39)			return;
            		}
HXLINE(  41)		{
HXLINE(  41)			 ::flixel::_hx_system::debug::interaction::tools::_Pointer::State _g = this->state;
HXDLIN(  41)			switch((int)(_g->_hx_getIndex())){
            				case (int)0: {
HXLINE(  45)					if (this->_brain->pointerJustPressed) {
HXLINE(  46)						this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::PRESS(this->_brain->flixelPointer->x,this->_brain->flixelPointer->y);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE(  48)					Float startX = _g->_hx_getFloat(0);
HXDLIN(  48)					Float startY = _g->_hx_getFloat(1);
HXLINE(  49)					if (this->_brain->pointerJustReleased) {
HXLINE(  51)						 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(  51)						_this->x = startX;
HXDLIN(  51)						_this->y = startY;
HXDLIN(  51)						_this->width = ( (Float)(0) );
HXDLIN(  51)						_this->height = ( (Float)(0) );
HXDLIN(  51)						 ::flixel::math::FlxRect rect = _this;
HXDLIN(  51)						rect->_inPool = false;
HXDLIN(  51)						 ::flixel::math::FlxRect selection = rect;
HXLINE(  52)						 ::flixel::FlxObject topItem = this->_brain->getTopItemWithinState(::flixel::FlxG_obj::game->_state,selection);
HXLINE(  53)						this->updateSelected(::flixel::_hx_system::debug::interaction::tools::_Pointer::Selection_obj::TOP(topItem));
HXLINE(  54)						if (!(selection->_inPool)) {
HXLINE(  54)							selection->_inPool = true;
HXDLIN(  54)							selection->_weak = false;
HXDLIN(  54)							::flixel::math::FlxRect_obj::_pool->putUnsafe(selection);
            						}
HXLINE(  56)						this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::IDLE_dyn();
            					}
            					else {
HXLINE(  58)						bool _hx_tmp;
HXDLIN(  58)						if ((this->_brain->flixelPointer->x == startX)) {
HXLINE(  58)							_hx_tmp = (this->_brain->flixelPointer->y != startY);
            						}
            						else {
HXLINE(  58)							_hx_tmp = true;
            						}
HXDLIN(  58)						if (_hx_tmp) {
HXLINE(  59)							this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::DRAG(startX,startY);
            						}
            					}
            				}
            				break;
            				case (int)2: {
HXLINE(  61)					Float startX1 = _g->_hx_getFloat(0);
HXDLIN(  61)					Float startY1 = _g->_hx_getFloat(1);
HXLINE(  62)					if (this->_brain->pointerJustReleased) {
HXLINE(  64)						 ::flixel::math::FlxRect _this1 = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(  64)						_this1->x = startX1;
HXDLIN(  64)						_this1->y = startY1;
HXDLIN(  64)						_this1->width = ( (Float)(0) );
HXDLIN(  64)						_this1->height = ( (Float)(0) );
HXDLIN(  64)						 ::flixel::math::FlxRect rect1 = _this1;
HXDLIN(  64)						rect1->_inPool = false;
HXDLIN(  64)						 ::flixel::math::FlxRect selection1 = rect1;
HXLINE(  65)						::flixel::_hx_system::debug::interaction::tools::Pointer_obj::setAbsRect(selection1,startX1,startY1,this->_brain->flixelPointer->x,this->_brain->flixelPointer->y);
HXLINE(  66)						::Array< ::Dynamic> items = this->_brain->getItemsWithinState(::flixel::FlxG_obj::game->_state,selection1);
HXLINE(  67)						this->updateSelected(::flixel::_hx_system::debug::interaction::tools::_Pointer::Selection_obj::ALL(items));
HXLINE(  68)						if (!(selection1->_inPool)) {
HXLINE(  68)							selection1->_inPool = true;
HXDLIN(  68)							selection1->_weak = false;
HXDLIN(  68)							::flixel::math::FlxRect_obj::_pool->putUnsafe(selection1);
            						}
HXLINE(  70)						this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::IDLE_dyn();
            					}
            				}
            				break;
            			}
            		}
            	}


void Pointer_obj::updateSelected( ::flixel::_hx_system::debug::interaction::tools::_Pointer::Selection selection){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_76_updateSelected)
HXDLIN(  76)		 ::flixel::_hx_system::debug::interaction::tools::Pointer _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  78)		bool alt = this->_brain->keyPressed(18);
HXLINE(  79)		bool shift = this->_brain->keyPressed(16);
HXLINE(  81)		 ::flixel::group::FlxTypedGroup selected = this->_brain->selectedItems;
HXLINE(  84)		switch((int)(selection->_hx_getIndex())){
            			case (int)0: {
HXLINE( 101)				 ::flixel::FlxObject _g = selection->_hx_getObject(0).StaticCast<  ::flixel::FlxObject >();
HXLINE(  86)				if (::hx::IsNull( _g )) {
HXLINE(  86)					bool _hx_tmp;
HXDLIN(  86)					if (!(alt)) {
HXLINE(  86)						_hx_tmp = shift;
            					}
            					else {
HXLINE(  86)						_hx_tmp = true;
            					}
HXDLIN(  86)					if (!(_hx_tmp)) {
HXLINE(  90)						this->_brain->clearSelection();
            					}
            				}
            				else {
HXLINE(  91)					 ::flixel::FlxObject item = _g;
HXDLIN(  91)					if (alt) {
HXLINE(  93)						if (_gthis->_brain->selectedItems->members->contains(item)) {
HXLINE(  94)							selected->remove(item,null()).StaticCast<  ::flixel::FlxObject >();
            						}
            					}
            					else {
HXLINE(  95)						 ::flixel::FlxObject item1 = _g;
HXDLIN(  95)						if (shift) {
HXLINE(  97)							if (_gthis->_brain->selectedItems->members->contains(item1)) {
HXLINE(  98)								selected->remove(item1,null()).StaticCast<  ::flixel::FlxObject >();
            							}
            							else {
HXLINE( 100)								selected->add(item1).StaticCast<  ::flixel::FlxObject >();
            							}
            						}
            						else {
HXLINE( 101)							 ::flixel::FlxObject item2 = _g;
HXDLIN( 101)							{
HXLINE( 103)								this->_brain->clearSelection();
HXLINE( 104)								selected->add(item2).StaticCast<  ::flixel::FlxObject >();
            							}
            						}
            					}
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 119)				::Array< ::Dynamic> _g1 = selection->_hx_getObject(0).StaticCast< ::Array< ::Dynamic> >();
HXDLIN( 119)				if ((_g1->length == 0)) {
HXLINE(  86)					bool _hx_tmp1;
HXDLIN(  86)					if (!(alt)) {
HXLINE(  86)						_hx_tmp1 = shift;
            					}
            					else {
HXLINE(  86)						_hx_tmp1 = true;
            					}
HXDLIN(  86)					if (!(_hx_tmp1)) {
HXLINE(  90)						this->_brain->clearSelection();
            					}
            				}
            				else {
HXLINE( 105)					::Array< ::Dynamic> items = _g1;
HXDLIN( 105)					if (alt) {
HXLINE( 107)						int _g2 = 0;
HXDLIN( 107)						while((_g2 < items->length)){
HXLINE( 107)							 ::flixel::FlxObject item3 = items->__get(_g2).StaticCast<  ::flixel::FlxObject >();
HXDLIN( 107)							_g2 = (_g2 + 1);
HXLINE( 109)							if (_gthis->_brain->selectedItems->members->contains(item3)) {
HXLINE( 110)								selected->remove(item3,null()).StaticCast<  ::flixel::FlxObject >();
            							}
            						}
            					}
            					else {
HXLINE( 112)						::Array< ::Dynamic> items1 = _g1;
HXDLIN( 112)						if (shift) {
HXLINE( 114)							int _g3 = 0;
HXDLIN( 114)							while((_g3 < items1->length)){
HXLINE( 114)								 ::flixel::FlxObject item4 = items1->__get(_g3).StaticCast<  ::flixel::FlxObject >();
HXDLIN( 114)								_g3 = (_g3 + 1);
HXLINE( 116)								if (_gthis->_brain->selectedItems->members->contains(item4)) {
HXLINE( 117)									selected->add(item4).StaticCast<  ::flixel::FlxObject >();
            								}
            							}
            						}
            						else {
HXLINE( 119)							::Array< ::Dynamic> items2 = _g1;
HXDLIN( 119)							{
HXLINE( 121)								this->_brain->clearSelection();
HXLINE( 122)								{
HXLINE( 122)									int _g4 = 0;
HXDLIN( 122)									while((_g4 < items2->length)){
HXLINE( 122)										 ::flixel::FlxObject item5 = items2->__get(_g4).StaticCast<  ::flixel::FlxObject >();
HXDLIN( 122)										_g4 = (_g4 + 1);
HXLINE( 123)										selected->add(item5).StaticCast<  ::flixel::FlxObject >();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Pointer_obj,updateSelected,(void))

void Pointer_obj::cancelSelection(){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_131_cancelSelection)
HXDLIN( 131)		this->state = ::flixel::_hx_system::debug::interaction::tools::_Pointer::State_obj::IDLE_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Pointer_obj,cancelSelection,(void))

void Pointer_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_135_draw)
HXLINE( 136)		 ::openfl::display::Graphics gfx = this->_brain->getDebugGraphics();
HXLINE( 137)		if (::hx::IsNull( gfx )) {
HXLINE( 138)			return;
            		}
HXLINE( 140)		{
HXLINE( 140)			 ::flixel::_hx_system::debug::interaction::tools::_Pointer::State _g = this->state;
HXDLIN( 140)			switch((int)(_g->_hx_getIndex())){
            				case (int)0: {
            				}
            				break;
            				case (int)1: {
HXLINE( 142)					Float _g1 = _g->_hx_getFloat(0);
HXDLIN( 142)					Float _g2 = _g->_hx_getFloat(1);
            				}
            				break;
            				case (int)2: {
HXLINE( 143)					Float startX = _g->_hx_getFloat(0);
HXDLIN( 143)					Float startY = _g->_hx_getFloat(1);
HXDLIN( 143)					{
HXLINE( 144)						 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 144)						_this->x = ( (Float)(0) );
HXDLIN( 144)						_this->y = ( (Float)(0) );
HXDLIN( 144)						_this->width = ( (Float)(0) );
HXDLIN( 144)						_this->height = ( (Float)(0) );
HXDLIN( 144)						 ::flixel::math::FlxRect rect = _this;
HXDLIN( 144)						rect->_inPool = false;
HXDLIN( 144)						 ::flixel::math::FlxRect rect1 = rect;
HXLINE( 145)						::flixel::_hx_system::debug::interaction::tools::Pointer_obj::setAbsRect(rect1,startX,startY,this->_brain->flixelPointer->x,this->_brain->flixelPointer->y);
HXLINE( 147)						gfx->lineStyle(((Float)0.9),12255232,null(),null(),null(),null(),null(),null());
HXLINE( 148)						gfx->drawRect((::flixel::FlxG_obj::camera->scroll->x + rect1->x),(::flixel::FlxG_obj::camera->scroll->y + rect1->y),rect1->width,rect1->height);
HXLINE( 149)						if (!(rect1->_inPool)) {
HXLINE( 149)							rect1->_inPool = true;
HXDLIN( 149)							rect1->_weak = false;
HXDLIN( 149)							::flixel::math::FlxRect_obj::_pool->putUnsafe(rect1);
            						}
            					}
            				}
            				break;
            			}
            		}
HXLINE( 153)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 154)			::flixel::FlxG_obj::camera->buffer->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


void Pointer_obj::setAbsRect( ::flixel::math::FlxRect rect,Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_dbe290ee08dc8b7a_158_setAbsRect)
HXLINE( 159)		Float _hx_tmp;
HXDLIN( 159)		if ((x1 < x2)) {
HXLINE( 159)			_hx_tmp = x1;
            		}
            		else {
HXLINE( 159)			_hx_tmp = x2;
            		}
HXDLIN( 159)		rect->x = _hx_tmp;
HXLINE( 160)		Float _hx_tmp1;
HXDLIN( 160)		if ((y1 < y2)) {
HXLINE( 160)			_hx_tmp1 = y1;
            		}
            		else {
HXLINE( 160)			_hx_tmp1 = y2;
            		}
HXDLIN( 160)		rect->y = _hx_tmp1;
HXLINE( 161)		Float _hx_tmp2;
HXDLIN( 161)		if ((x1 < x2)) {
HXLINE( 161)			_hx_tmp2 = (x2 - x1);
            		}
            		else {
HXLINE( 161)			_hx_tmp2 = (x1 - x2);
            		}
HXDLIN( 161)		rect->width = _hx_tmp2;
HXLINE( 162)		Float _hx_tmp3;
HXDLIN( 162)		if ((y1 < y2)) {
HXLINE( 162)			_hx_tmp3 = (y2 - y1);
            		}
            		else {
HXLINE( 162)			_hx_tmp3 = (y1 - y2);
            		}
HXDLIN( 162)		rect->height = _hx_tmp3;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Pointer_obj,setAbsRect,(void))


::hx::ObjectPtr< Pointer_obj > Pointer_obj::__new() {
	::hx::ObjectPtr< Pointer_obj > __this = new Pointer_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Pointer_obj > Pointer_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Pointer_obj *__this = (Pointer_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Pointer_obj), true, "flixel.system.debug.interaction.tools.Pointer"));
	*(void **)__this = Pointer_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Pointer_obj::Pointer_obj()
{
}

void Pointer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Pointer);
	HX_MARK_MEMBER_NAME(state,"state");
	 ::flixel::_hx_system::debug::interaction::tools::Tool_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Pointer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(state,"state");
	 ::flixel::_hx_system::debug::interaction::tools::Tool_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Pointer_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { return ::hx::Val( init_dyn() ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { return ::hx::Val( state ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateSelected") ) { return ::hx::Val( updateSelected_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"cancelSelection") ) { return ::hx::Val( cancelSelection_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Pointer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"setAbsRect") ) { outValue = setAbsRect_dyn(); return true; }
	}
	return false;
}

::hx::Val Pointer_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"state") ) { state=inValue.Cast<  ::flixel::_hx_system::debug::interaction::tools::_Pointer::State >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Pointer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("state",11,76,0b,84));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Pointer_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::_hx_system::debug::interaction::tools::_Pointer::State */ ,(int)offsetof(Pointer_obj,state),HX_("state",11,76,0b,84)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Pointer_obj_sStaticStorageInfo = 0;
#endif

static ::String Pointer_obj_sMemberFields[] = {
	HX_("state",11,76,0b,84),
	HX_("init",10,3b,bb,45),
	HX_("update",09,86,05,87),
	HX_("updateSelected",84,1d,97,e6),
	HX_("cancelSelection",72,6b,d1,ed),
	HX_("draw",04,2c,70,42),
	::String(null()) };

::hx::Class Pointer_obj::__mClass;

static ::String Pointer_obj_sStaticFields[] = {
	HX_("setAbsRect",34,af,0f,b1),
	::String(null())
};

void Pointer_obj::__register()
{
	Pointer_obj _hx_dummy;
	Pointer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.system.debug.interaction.tools.Pointer",26,c4,01,fa);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Pointer_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Pointer_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Pointer_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Pointer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Pointer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Pointer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace system
} // end namespace debug
} // end namespace interaction
} // end namespace tools
